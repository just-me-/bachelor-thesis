\section{Implementation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Client}
a



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Server}


\subsubsection{Server Launch}
As done in common practice, the \code{Main} function is kept very short. All it does is launching the language server, which is already handled by another class.

\begin{lstlisting}[language=csharp, caption={Main Function}, captionpos=b, label={lst:main}]
public static async Task Main(string[] args)
{
    DafnyLanguageServer languageServer = new DafnyLanguageServer(args);
    await languageServer.StartServer();
}
\end{lstlisting}

The launch of the server itself is devided into four stages. First, preparational work is done. This happens already in the constructor of the language server. Preparation includes
\begin{itemize}
    \item Reading and processing config variables
    \item Setting up the logging framework
\end{itemize}
Secondly, the actual server is launched. The logger will directly be injected and all handlers are registred. In the third stage, once the server is running, a message sending service is instanciated to notify the client about the successful server start and, if any, errors occured during startup. Lastly, the console output stream is redirected to keep the langauge server stream clean.

\begin{lstlisting}[language=csharp, caption={Starting the Language Server}, captionpos=b, label={lst:serverstart}]
public async Task StartServer()
{
    log.Debug(Resources.LoggingMessages.server_starting);
    server = await LanguageServer.From(options => \dots  );
    ExecutePostLaunchTasks();
    await RedirectStreamUntilServerExits();
    log.Debug(Resources.LoggingMessages.server_closed);
}
\end{lstlisting}

\subsubsection{Tools}
Within the tools package, a variety of services can be found that do not necessarily directly correspond to Dafny, but are useful within the language server environment.\\

\textbf{Config Initializer}\\
\intnote{kann man hier so subsubsubchapter machen? geht das iwie? sons tienfach so lassen oder?}
This class is called prior to the server launch and initializes a few config settings. The settings are stored within the static class \code{Commons/LanguageServerconfig.cs}. The config initializer will first of all set hard coded default values to avoid any kind of null pointer exceptions. Afterwards, the file \code{Config/LanguageServerConfig.json} is parsed with Newtonsoft's Json.NET library \cite{jsondotnet}. Any available values will be written to the static configuration class. Unkown or illegal values will not be set and errors are added to a error reporter. Finally, the launch arguments are parsed, again overwritting the config settings if applicable or reporting errors otherwise. A simple argument parser was implemented manually. Alternatively, a library could have been used for this task such as \cite{clparser}. The config initalizer is implemented exception safe. This means that it will run to completion and at wrost just provide default values. Errors can later be extracted from the \code{InitializationErrors} property.\\

\textbf{LoggerCreator}\\
This class simply sets up a Serilog \cite{serilog} logger. For this purpose, it will already read from the static config class \code{Commons/LanguageServerconfig.cs} the information what the minimum loglevel is and where to locate the logfile.\\

\textbf{MessageSenderService}\\
This is a simple class accepting a \code{ILanguageServer} in the constructor. Afterwards, it provides methods to send notifications to the client. Simliar to logging, methods for each severity level are available, such as \code{public void SendError(string msg)}.\\

\textbf{ReservedWordsProvider}\\
This is a class reporting simply offering a method returning a set of words, that are not suited for identifiers. This is, for example, 'method', 'class', or 'return'. The class tries to read and parse \code{Config/ReservedDafnyWords.json}, which can be user adjusted in case the Dafny specification changes. If the file cannot be read or has a wrong format, a hard coded default list is used which was taken out from the Dafny Reference Manual \cite{dafnyReferenceManual}.\\

While this component is specifically used solely for the \code{rename}-Feature, it was extracted to be also available at other spots if required for future features.\\

\subsubsection{Handler}
Vererbung, splitted nach custom und dingsen, blabla, callen nur service.
logging wird injected, worksapce wird injected.

\subsubsection{Core}
Eigentliche logik. implementiert interface. Die Features ev einzln druch, msus man fast, hat ja vieles interessantes, z.b. so diagnostic conversion (wobie xcdas bei dafny access is)

\subsubsection{Workspace}
Eifnach der KEy Value store
File REpo hat alles drin, resultat und symbol table shit.

\subsubsection{DafnyAccess}
Most interesting part...
DTU called eigetnlich dafny core.
da den abluaf erklren
dann so dass die errors collected werden.
total integrated.

\subsection{Symbol Table}



\textbf{Feature Support}

Split in creation, manageing, navigation
Symbol eigenes teil.
properties aufzeigen


Since we have object information (and not just strings anymore) with our self-written symbol table,
the whole position to string parsing was dropped. \\

In our old version we had to find out from the current cursor position which word in the code could be meant.
Then we iterated over the whole symbol table and checked if there was a symbol with the same string as name.
The first match was looked at as a meant symbol. \\

Our new design eliminates all of this effort and avoidable assumptions.
We access the currently marked symbol directly via the position data.
String comparisons and corresponding string extractions are completely eliminated.
This leads to better performance and above all to reliable symbol references.


\textbf{Navigator}
To use the constructed symbol table, we offer a separate navigation component.
This navigator has basically two procedures.
\begin{itemize}
\item TopDown: Starting from a node, the navigator decides in which childNode the target can be located and recursively searches those, until a best match is found.
\item BottomUp: Starting from a node, the navigator moves upwards and returns the first, or all, symbols matching a criterion.
\end{itemize}

For example: TopDown is used especially when searching for symbols at the cursor position.
The iteration will check for each child node, it the cursor is covered by the symbol body.
If so, search will continue within that child node.
If not, that child symbol is not visited.
This avoids a runtime of O(n) for each search. \intnote{ist schnell einfach schreiben}
In a dafny file, which was structured very quickly - for example only functions in the highest level - the worst case of O(n) is still reached. \intnote{(das ist nicht richtig...) symbole in der function werden incht visited. ist deutlichs chneller. nur bei der tzarget function geht man rein.}


\intnote{2do Bild von nem baum und dann wie es so hoch und runter geht, Beispiel, Visualisierung einbauen fuer die Laufzeitanalyse.} \\

To enable efficient access to the entry points, we have opted for a key-value data structure. The key is the child symbol's name, the value the actual \code{SymbolInformation} object.
This hash structure enables us to access child symbols with a runtime of O(1). Since every symbol also has a link to it's parent, navigation in both ways can be done within O(1).

2do hier noch etwas genauer drauf eingehen... visualisieren... hash besser begruenden. Naja finds eig gut. steht ja da dass der grund O1 ist.

\textbf{Runtime}

\intnote{aufbau runtime}
\intnote{warum steht schon oben was von O(1) wenn hier runtime kommt?}

The features themselves are primarily based on the symbol table.
In particular auto completion, go to definition, CodeLens, hover information and rename. \\

Due to the structure of our Symbol table (which is updated after every change in a Dafny file)
the basic information is provided by references.
Each symbol carries references to its child simbols, to the parent symbol, to the original declaration and much more information.
All these references were prepared when the symbol table was created. You can therefore call them immediately (runtime O(1)).  \intnote{Das steh talles schon oben...}

The difficulty lies in finding the "entry symbol".

The navigation component described above is used for this. The system uses the cursor position to find the deepest symbol that encloses the cursor position. This symbol is the entry point. And to find this symbol, the longest runtime is required for the features - apart from the creation of the actual symbol table of course.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Testing}
meh. evtl kann man was ubernehemn.  Integration test sind ja eig schon vom design her erledigt. vlt nochwso bissl allgemein mimi viele faelle abgedeckt blabla.

\subsection{Code Reviews}
\intnote{ich glaube es ist nicht gedacht einzelne code reviews zu dokumentieren. das waere ja mehr dann wie ein arbbeitsrapport, aka woche 12: wir haben das code review bearbeitet und dies und das gemacht. eher so bei kapitel design: wir haben entschieden, strings da und da auszulagnern. dies wurde u.a. wegen dem code review so geamcht. dann implementation: hier wurde das so und so implementiert, weil beim code review es so gesagt wurde}
Fabians Feedback aus der SA... neues Review. "Tu Gutes und sprich davon".

\subsubsection{Client Code Review}
After a joint code review together with our advisors, individual optimisation potential was identified.
This subchapter describes the associated improvements to the architecture. \\

Although interfaces were used for the individualized types,
the individual core components did not use their own interfaces.
To reduce coupling, isolated modules were formed in a comprehensive refactoring process.
The modules now no longer program on the class implementations, but against the interface. \\

For this purpose one importable module with the name \code{\_<Directory>Modules} was created for each directory.
Figure \ref{fig:client_2nd_refactoring} shows an overview of the interfaces.
In addition, the dependencies among each other are shown.
For simplicity, the contents of \code{stringRessources} and \code{typeInterfaces} have been omitted. \\

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{client_2nd_refactoring.png}
    \caption{Second Major Client Refactoring}
    \label{fig:client_2nd_refactoring}
\end{figure}

At first glance, the architecture appears much tidier.
The dependencies are now pointing from top to bottom.
Methods have been simplified and the number of parameters could be reduced significantly.
Component identifiers have been renamed to be more understandable. \\

However, it is now also noticeable that there are considerably more dependencies on \code{stringRessources}.
While in the previous version only the module \code{ui} used \code{stringResources}, it is now used by almost all other modules.

This has the following reason: Up until this refactoring, the task of \code{stringResources} was to be a central collection of all UI strings. \glsadd{UI}
In the code review, it was decided that default values should no longer be set within the independent modules,
but rather at a central location.
This would make it easier to maintain these values. \\



\textbf{m}
\textbf{m}
\textbf{m}
\textbf{m}
\textbf{m}
\textbf{m}



\subsection{Usability Test Verschieben nach Kapitel Results}


\subsection{Mono Support for macOS and Linux -Kaptitel nicht hier. entweder anaylse oder Result}
Eines der Kernzeiele war es, Support fuer mehrere Plattformen zu bieten. Dh nebst Windows auch macOS und Linux.
Da wir in unserer SA von Core auf Framework umsteigen musste, stand fest, dass wir mono fuer den Support auf Linux und macOS brauchen.
(warum in der SA; plficht wegen dafny core. was ist mono)

Leider funktionierts nicht.
Anssaetze die wir probiert haben. verschiedene mono versionen, angefragt im slack. antwort erhalten?
github issues: allgemein probleme mit lunux/mac weil primaer auf windows und gar nicht auf mac getestet wird. (heikle aussage selbs tmit quelle)

\cite{sa}
\cite{mono-slack}
\cite{mono-git}
