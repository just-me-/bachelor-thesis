\section{Implementation}

\subsection{Symbol Table}

\subsubsection{Feature Support}
Since we have object information (and not just strings anymore) with our self-written symbol table,
the whole position to string parsing was dropped. \\

In our old version we had to find out from the current cursor position which word in the code could be meant.
Then we iterated over the whole symbol table and checked if there was a symbol with the same string as name.
The first match was looked at as a meant symbol. \\

Our new design eliminates all of this effort and avoidable assumptions.
We access the currently marked symbol directly via the position data.
String comparisons and corresponding string extractions are completely eliminated.
This leads to better performance and above all to reliable symbol references.

\subsubsection{Code Review}
Fabians Feedback aus der SA... neues Review. "Tu Gutes und sprich davon".

\subsection{Client Code Review}
Fedback Fabian und Thomas. Interface für Koopelung, weniger Kommentar, mehr Interfaces. Besseres Naming für Variablen. Mehr Interfaces.
Beschreiben wie es nun neu aussehen wird.

\subsection{Runtime Analysis of the Essential Server Components}
\subsubsection{Generation of the Symbol Table}
Ich glaub beim Aufbau verwendest du nur einmal den Navigator oder? Also n*n Laufzeit?

\subsubsection{Use of the Symbol Table}
To use the constructed symbol table, we offer a separate navigation component.
This navigator has basically two visit procedures.
Once from a symbol in the symbol tree up. And once from the root node of the tree down. \\

The TopDown approach searches down from the entry point and automatically limits the search areas. \\

For example: TopDown is used especially when searching for symbols at certain positions.
If the iteration encounters a symbol that does not cover the range of the search position,
the child symbols are not even visited.
This avoids a runtime of O(n) for each search. In a dafny file, which was structured very quickly - for example only functions in the highest level - the worst case of O(n) is still reached.

2do Bild, Beispiel, Visualisierung einbauen für die Laufzeitanalyse. \\

To enable efficient access to the entry points, we have opted for a key-value data structure. The key is the symbol name corresponding to each symbol. This hash structure enables us to access module symbols as entry points with a runtime of O(1). This was especially necessary because certain default modules are automatically created by Dafny if the programmer does not define his own modules.
2do hier noch etwas genauer drauf eingehen... visualisieren... hash besser begründen.

The second search approach is ButtomUp.
The entry point is a symbol.
Starting from this symbol, the system searches for symbols within the reachable scope of the reference symbol. \\

This approach is used for auto completion, for example.
Starting from a passed symbol, all symbols are searched in the corresponding available scope.

\subsubsection{Corresponding Duration of the Individual Features}
The features themselves are primarily based on the symbol table.
In particular auto completion, go to definition, CodeLens, hover information and rename. \\

Due to the structure of our Symbol table (which is updated after every change in a Dafny file)
the basic information is provided by references.
Each symbol carries references to its child simbols, to the parent symbol, to the original declaration and much more information.
All these references were prepared when the symbol table was created. You can therefore call them immediately (runtime O(1)).

The difficulty lies in finding the "entry symbol".

The navigation component described above is used for this. The system uses the cursor position to find the deepest symbol that encloses the cursor position. This symbol is the entry point. And to find this symbol, the longest runtime is required for the features - apart from the creation of the actual symbol table of course.

\textbf{m}
\textbf{m}
\textbf{m}
\textbf{m}
\textbf{m}
\textbf{m}

\subsection{Usability Test}


\subsection{Mono Support for macOS and Linux}
Eines der Kernzeiele war es, Support für mehrere Plattformen zu bieten. Dh nebst Windows auch macOS und Linux.
Da wir in unserer SA von Core auf Framework umsteigen musste, stand fest, dass wir mono für den Support auf Linux und macOS brauchen.
(warum in der SA; plficht wegen dafny core. was ist mono)

Leider funktionierts nicht.
Anssätze die wir probiert haben. verschiedene mono versionen, angefragt im slack. antwort erhalten?
github issues: allgemein probleme mit lunux/mac weil primär auf windows und gar nicht auf mac getestet wird. (heikle aussage selbs tmit quelle)

\cite{sa}
\cite{mono-slack}
\cite{mono-git}
