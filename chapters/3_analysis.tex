\section{Analysis}
\label{section:analysis}
Since this thesis is a direct sequel of the preceding semester thesis, work could be directly continued. However, to provide the reader with a comprehensive knowledge base about Dafny and the language server protocol, some chapters out of the semester thesis will be repeated in the following subsections. To be able to create the symbol table, more detailled research about Dafny's language feature and its AST element had to be done, which is also described in this chapter.

\subsection{Language Server Protocol}
\label{section:analysis:lsp}
The language server protocol (LSP) is a JSON-RPC based protocol to communicate between an IDE and a language server \cite{dafnyWiki}. In 2016, Microsoft started collaborating with Red Hat and Codenvy to standardize the protocolâ€™s specification \cite{dafnyWiki}. The goal of the LSP is to untie the dependency of an IDE with its programming language. That means, that once a language server is available, the user is free in the choice of his IDE, as long as it offers a client instance that is able to communicate with the server. The user can then use a variety of features, as long as the language server offers them. Those features can for example be auto completions, hover information, or go to definition. Custom message types, for example compile or counterExample can also be added to the LSP. \cite{dafnyWiki}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{03_lspcommunication.png}
    \caption{Communication Benefit of LSP}
    \label{fig:lspcommunication}
\end{figure}
A big advantage of this is that the IDE specific plugin can be kept very simple. The relevant information is delivered by the language server, which is IDE and language independent. Figure \ref{fig:lspcommunication} from the VSCode extension guide illustrates these benefits. \cite{lspextensionguide}

\subsubsection{Message Types}
The LSP supports three types of messages.
\begin{itemize}
    \item Notification: One-way message, for example for a console log or a window notification.
    \item Request: A message that expects a response.
    \item Response: The response to a request.
\end{itemize}
Each message type can be sent from both sides.

\subsubsection{Communication Example}
The basic concept of the lsp is, that the IDE tells the language server what the user is doing. These messages are pretty simple, namely \code{textdocument/didOpen} or \code{textDocument/didChange}. The language server on the other hand can now verify the opened or changed document and test it for errors. If errors are found, the server can send a \code{textDocument/publishDiagnostics} notification back to the client. The client may now underline the erroneous code range in red. \cite{lspspec}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{03_lspmsgexample.png}
    \caption{Example Communication}
    \label{fig:lspmsgexample}
\end{figure}






%%%%%%%%%%%%%%%%%%%%%% neu


\subsection{Dafny Language Features}
With regard to the symbol table, the Dafny language had to be studied more in detail. For example, overloading describes the existence of multiple methods with the same name, but different signatures. This is obviously highly relevant for the construction of a symbol table.
To be aware of which such concepts are supported - or prohibited - by Dafny, we studied the Dafny Reference Guide \cite{dafnyReferenceManual}. This chapter provides the reader with the most relevant concepts in regard to the symbol table. Of cousre, Dafny offers much more language features.


\subsubsection{Modules}
Dafny code can be organized with modules. A module can be compared to a namespace in \Csharp or C++. Modules can also be nested. To use a class, method or variable defined in another module, the user has three options. Imagine a method \texttt{addOne} defined in a module \texttt{Helpers}.

\begin{lstlisting}[caption={Module Example}, captionpos=b, label={lst:shadowing}]
    module Helpers {
        function method addOne(n: nat): nat {
            n + 1
        }
    }
\end{lstlisting}

\begin{itemize}
    \item The user writes the Module name explicitly in front of the method he wants to call, \linebreak namely \texttt{Helpers.addOne(5)}.
    \item The user imports the module, for example with \texttt{import H = Helpers}. Afterwards, he may type \texttt{H.addOne(5)}.
    \item The user imports the module in opened state: \texttt{import opened Helpers}. Now the user is eligible to skip the namespace identifier and can just write \texttt{addOne(5)}.
\end{itemize}

Importing a module in opened state may cause naming clashes. This is allowed, but in this case, the locally defined item has always priority over the imported item. For example, in listing \ref{lst:moduleShadowing}, the assert statemtn is violated, since the overwritten \texttt{addOne} has priority. \cite{functionVSMethod}

\begin{lstlisting}[caption={Naming Clash}, captionpos=b, label={lst:moduleShadowing}]
    module Helpers {
        function method addOne(n: nat): nat {
            n + 1
        }
    }
    function addOne(n: nat): nat {
        n + 2
    }

    import opened Helpers
    method m3() {
        assert addOne(5) == 6; //violated
    }

\end{lstlisting}

To import a module defined in another file, the user has to import the file using the command \texttt{include "myFile.dfy"}. This includes all content of the included file into the current file.

\subsubsection{Functions vs. Methods}
Dafny has two types of methods, or functions respectively. For a programmer used to \Csharp or C++, this concept may be confusing at first, but is very simple:
\begin{itemize}
\item A method is what a programmer from \Csharp or C++ may be used to. A sequence of code, accepting some parameters at the beginning and returning some values at the end. It can be a class member or be in global space.
\item A function is more like a mathematical function. It takes an input and returns a single value. The function may consist of only one expression. For example, consider listing \ref{lst:function}. Further, functions are not compiled and may only be used in specification context. That is, in contracts or assert statements to proof logical correctness. \cite{functionVSMethod}.
\item The Function Method is just both at once. It also contains of a single expression with a single return, but is also compiled and thus also available in regular context. \cite{functionVSMethod}
\end{itemize}

\begin{lstlisting}[caption={Function}, captionpos=b, label={lst:function}]
    function method minFunctionMethod(a:int, b:int):int
    {
        if a<b then a else b
    }
\end{lstlisting}

Further concepts include:
\begin{itemize}
\item A predicate is just a function returning a bool value.
\item An inductive predicate is a predicate calling itself.
\item A lemma is a mathematical fact. It can be called whenever Dafny cannot prove something on its own. By calling the lemma, the user tells Dafny a fact it can use for its proof. An example can be found in listing \ref{lst:lemma}. \cite{dafnyReferenceManual}
\end{itemize}

\begin{lstlisting}[caption={Lemma}, captionpos=b, label={lst:lemma}]
lemma ProovingMultiplication(c: int, m: int)
    ensures c*m == m + (c-1)*m
{}
\end{lstlisting}

\subsubsection{Hiding}
Hiding is when a derived class redefines a member variable of the base class. Dafny supports inheritance with traits. A trait is basically an abstract class. While the trait can define a class variable, any class deriving from it is not allowed to redefine that class variable. Consider the following example. The commented code line would cause an error. \cite{dafnyReferenceManual}

\begin{lstlisting}[caption={Hiding}, captionpos=b, label={lst:hiding}]
trait Base {
    var a: int
}

class Sub extends Base {
    constructor() {}
    //var a: int          //Error
}
\end{lstlisting}

This means that we do not have to consider this issue any further with regard to our symbol table.

\subsubsection{Overloading}
Overloading means defining the same method with a different signature. This is, with different parameters. Dafny prohibits this language concept to be able to uniquely identify each method by its name. \cite{dafnyReferenceManual}
This means, that whitin each module, each method name is unique.

\subsubsection{Shadowing}

Shadowing means that a class method redefines a variable that was already defined as a class member. This means that two variables with the same name exist. The local variable can be accessed via its name, but to access the class member, the programmer needs to write a \code{this} in front of the variable name. One can even go further and redefine a local variable in a nasted blockscope.\\

Consider the following code snippet. It defines a class with a member variable \code{a}. It is initialized with value 2 in the class constructor. In method \code{m}, the variable \code{a} is first of all printed. This will print 2, since the class variable is the only one we are aware of. Next, a variable with the same name is redefined. The class variable is now shadowed by the local variable. Printing a will now print the local variable. To access the class variable, the this-locator is necessary.

\begin{lstlisting}[caption={Complex Shadowing Example}, captionpos=b, label={lst:shadowing}]
    class A {
        constructor () { a := 2; }
        var a: int
        method m()
        modifies this
        {
            print a;           // 2
            var a: string := "hello";
            print a;           // hello
            print this.a;      // 2
            {
                print a;       // hello
                var a: bool := true;
                print a;       // true
                print this.a;  // 2
            }
        }
    }
\end{lstlisting}

Next, a nested scope is opened. Printing a at first will still yield the local variable. However, in the nested scope, we can redefine a again, shadowing the own local variable. Further calls of a will then print the boolean variable. \texttt{this.a} will still yield 2, even in the nested scope.\\

This behaviour can be summarized with the following three rules:
\begin{itemize}
    \item If the variable was defined locally before its usage, the local definition is significant.
    \item If the variable was not defined locally before its usage, the parent scope is significant.
    \item If a class member is called via the \texttt{this} identifier, the class member is significant.
\end{itemize}

Regarding the implementation, the definition of a symbol could be found using the following method. Prerequisite is though, the scope.AllSymbols returns only those symbols that are defined so far.

\lstset{style=sharpc}
\begin{lstlisting}[caption={Finding Symbol Definition}, captionpos=b, label={lst:findsymbol}]
private Symbol FindDeclaration(Symbol target, Symbol scope)
{
    foreach (Symbol s in scope.AllSymbols)
    {
        if (s.Name == target.Name && s.IsDeclaration)
        {
            return s;
        }
    }
    if (scope.Parent != null)
    {
        return FindDeclaration(target, scope.Parent);
    }
}
\end{lstlisting}

The code above would basically already resolve the \textit{GoTo Definition} problem.

\subsection{Symbol Table}
Was ist eine Symbol tAble?
Inwiefern modifiezeren wir das?
Dafny hta keine, drum selber bauen.

Was erwarten wir von der Symbol table?
Goto Def -> Wo ist die Deklaration?
Rename -> Get all usages with position.
Code Lens -> Get all usages


==> Gedanken zum Updaten sind wichtig. Evt ned alles implementieren aber dokumentieren.... Effizienz. Ned alles neu Builden
wenn in einem File nur ein Zeichen geÃ¤ndert wird auf einer Linie etc. ==> Ausblick.

Und Testing in einem grossen Dafny Project wÃ¤r evt auch noch ganz nice... ein paar Performance-Tests und so?
Und die dann mit dem Plugin aus der Studienarbeit vergleichen? Und dem alten-alten Plugin? KÃ¤me bestimmt jut an. 

The DafnyAst.cs is a File from Dafny, that is huge.
Eleven thousand lines of code and a large number of classes.
This is so extensive that even our IDE Visual Studio struggles with it and crashed on autocompletions. \\

Since this file and its contained classes will have to be extended by single methods
to implement a correct Visitor Pattern for our Symbol Table, we considered if we want to refactor the whole file.  \\

Splitting the file into individual class files and dividing it into a separate package would provide a mutch better overview.
From our point of view, the following advantages are particularly evident:
\begin{itemize}
    \item Clearer separation
    \item Better overview
    \item Better IDE performance
    \item As a result, less error-prone coding
\end{itemize}

However, there would also be individual disadvantages:
\begin{itemize}
    \item Time-consuming
    \item Inconsistent. All other files would still be in the same style. Refactoring should then be extended
    \item The maintainers of Dafny maybe do not want a refactored style at all, because they are used to the current style
    \item By swapping out all lines of code, the top level of the githistory would be disturbed for git blame
\end{itemize}

We decided not to carry out a refactoring.
It would be very time consuming and we would have to refactor all the other files of Dafny for the unit.

We simply do not have the time for this in our bachelor thesis,
because we would like to improve and refactor our code continuously.
Especially with the new symbol table, structures in our code part are changing.
We would like to have enough time for this and that is the priority we set.
To refactor the code of Dafny itself is one of the possible outlooks of this work.

%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Continuous Integration (CI)}
Continuous integration is a verry important part for code quality improvement and colaboration.
Unfortunately, the CI process in our student research project extended to almost the entire semester \cite{sa}. \\

According to our project plan, we wanted to work on open points regarding the CI initially and have completed the theme accordingly for the remaining duration of the bachelor thesis.

\subsubsection{Initial Situation}
We achieved in our client CI that code was analyzed with SonarQube and the build failed if it contained TypeScript errors \cite{sa}.
We did not achieve it within reasonable time headless integration test \cite{sa}. \\

On the server side we reached the build process as well as the dafny tests and our own unit tests \cite{sa}.
Automated integration tests and code analysis by SonarQube remained outstanding \cite{sa}.

\subsubsection{Aimed Solution}
According to our research, a major problem was that the scanner for sonarqube does not support any other languages besides C\# \cite{sonar-supports-only-one-language}.
This means that in addition to C\# in a project, TypeScript (for the client) cannot be analyzed simultaneously.
Furthermore there are also single Java files in Dafny project.
This also led to conflicts in the Sonar analysis in our student research project \cite{sa}. \\

As a simple solution we decided to separate the client (VSCode plugin) and server (Dafny Language Server) into two separate git repositories.
This not only simplifies the CI process but also ensures a generally better and clearer separation. \\

As a result, the client could still be easily analyzed with the previous Sonar scanner.
For the Language Server in C\# a special Sonar scannerfor MSBuild had to be used, which publishes the analysis in a separate SonarCloud project \cite{dev}.
Beside the code from our Lanugae server the whole Dafny project code is now analyzed by sonar.
This can be very helpful for code reviews. \\

The only downside is that the code coverage is not analyzed.
For .NET OpenCover is a very common tool for code coverage analysis.
Unfortunately, it only works on windows and not on our linux CI server \cite{opencover}.
Other tools that works with mono Support .NET Core but not Framework.
During our research we came across monocov \cite{monocov}. This tool would support mono for .NET Framework. Unfortunately this project was archived and has not been supported for almost 10 years \cite{monocov}.

Since we would not gain much added value with sonar code coverage, we decided not to pursue this approach any further. The coverage information is provided by the locally installed IDEs anyway.
\\

For an easier testability of the CI, we now also used local docker. This allows us to test CI customizations efficiently. See the developer documentation for more details \cite{dev}. \\

The headless integration tests were a bit more tricky.
In consultation with our supervisor, we have removed these tests from the client project and replaced them with own specially written integration tests on the server side.

\subsubsection{Docker}
As mentioned in the previous chapter, we rely on Docker.
The simplicity of Docker Container allows us a comfortable way to integrate the building and testing process into our CI.

Furthermore, the lightweight virtualization is ideally suited to run and debug our Linux CI environment
locally and platform-independently (through the Docker Client) in case of problems. \\

Furthermore we can easily realize the priciple "Cattle, not a pet" with docker.
Instead of having certain package dependencies that need to be updated continuously (pet), we use a "build, throw away, rebuild" procedure (cattle). So we don't have to worry about security patches and the like. We simply install the latest versions when we create a docker. \\

Excluded from this are of course specific versions such as Node, Z3, Go, Boogie and Sonar.
There the version to be installed is explicitly specified, since version changes there
can have essential impairments of the Language Server's function. See the developer documentation for more details \cite{dev}. \\

\subsubsection{2do - Kapitelaufteilung komisch}
Ich hab hier jetzt in der Analyse auch schon die LÃ¶sung vorabgegriffen. Sollen wir das splitten? Bricht das nicht den Lesefluss? Evt besprechen.
