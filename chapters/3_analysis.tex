\section{Analysis}
\subsection{Dafny Language Features}
With regard to the symbol table, the Dafny language had to be studied more in detail. For example, overloading describes the existence of multiple methods with the same name, but different signatures. This is obviously highly relevant for the construction of a symbol table.
To be aware of which such concepts are supported - or prohibited - by Dafny, we studied the Dafny Reference Guide \cite{dafnyReferenceManual}. This chapter provides the reader with the most relevant concepts in regard to the symbol table. Of cousre, Dafny offers much more language features.


\subsubsection{Modules}
Dafny code can be organized with modules. A module can be compared to a namespace in \Csharp or C++. Modules can also be nested. To use a class, method or variable defined in another module, the user has three options. Imagine a method \texttt{addOne} defined in a module \texttt{Helpers}.

\begin{lstlisting}[caption={Module Example}, captionpos=b, label={lst:shadowing}]
    module Helpers {
        function method addOne(n: nat): nat {
            n + 1
        }
    }
\end{lstlisting}

\begin{itemize}
    \item The user writes the Module name explicitly in front of the method he wants to call, \linebreak namely \texttt{Helpers.addOne(5)}.
    \item The user imports the module, for example with \texttt{import H = Helpers}. Afterwards, he may type \texttt{H.addOne(5)}.
    \item The user imports the module in opened state: \texttt{import opened Helpers}. Now the user is eligible to skip the namespace identifier and can just write \texttt{addOne(5)}.
\end{itemize}

Importing a module in opened state may cause naming clashes. This is allowed, but in this case, the locally defined item has always priority over the imported item. For example, in listing \ref{lst:moduleShadowing}, the assert statemtn is violated, since the overwritten \texttt{addOne} has priority. \cite{functionVSMethod} 

\begin{lstlisting}[caption={Naming Clash}, captionpos=b, label={lst:moduleShadowing}]
    module Helpers {
        function method addOne(n: nat): nat {
            n + 1
        }
    }
    function addOne(n: nat): nat {
        n + 2
    }

    import opened Helpers  
    method m3() {
        assert addOne(5) == 6; //violated
    }

\end{lstlisting}

To import a module defined in another file, the user has to import the file using the command \texttt{include "myFile.dfy"}. This includes all content of the included file into the current file.

\subsubsection{Functions vs. Methods}
Dafny has two types of methods, or functions respectively. For a programmer used to \Csharp or C++, this concept may be confusing at first, but is very simple:
\begin{itemize}
\item A method is what a programmer from \Csharp or C++ may be used to. A sequence of code, accepting some parameters at the beginning and returning some values at the end. It can be a class member or be in global space.
\item A function is more like a mathematical function. It takes an input and returns a single value. The function may consist of only one expression. For example, consider listing \ref{lst:function}. Further, functions are not compiled and may only be used in specification context. That is, in contracts or assert statements to proof logical correctness. \cite{functionVSMethod}.
\item The Function Method is just both at once. It also contains of a single expression with a single return, but is also compiled and thus also available in regular context. \cite{functionVSMethod} 
\end{itemize}

\begin{lstlisting}[caption={Function}, captionpos=b, label={lst:function}]
    function method minFunctionMethod(a:int, b:int):int
    {
        if a<b then a else b
    }
\end{lstlisting}

Further concepts include:
\begin{itemize}
\item A predicate is just a function returning a bool value.
\item An inductive predicate is a predicate calling itself.
\item A lemma is a mathematical fact. It can be called whenever Dafny cannot prove something on its own. By calling the lemma, the user tells Dafny a fact it can use for its proof. An example can be found in listing \ref{lst:lemma}. \cite{dafnyReferenceManual}
\end{itemize}

\begin{lstlisting}[caption={Lemma}, captionpos=b, label={lst:lemma}]
lemma ProovingMultiplication(c: int, m: int)
    ensures c*m == m + (c-1)*m
{}
\end{lstlisting}

\subsubsection{Hiding}
Hiding is when a derived class redefines a member variable of the base class. Dafny supports inheritance with traits. A trait is basically an abstract class. While the trait can define a class variable, any class deriving from it is not allowed to redefine that class variable. Consider the following example. The commented code line would cause an error. \cite{dafnyReferenceManual}

\begin{lstlisting}[caption={Hiding}, captionpos=b, label={lst:hiding}]
trait Base {
    var a: int
}

class Sub extends Base {
    constructor() {}
    //var a: int          //Error
}
\end{lstlisting}

This means that we do not have to consider this issue any further with regard to our symbol table.

\subsubsection{Overloading}
Overloading means defining the same method with a different signature. This is, with different parameters. Dafny prohibits this language concept to be able to uniquely identify each method by its name. \cite{dafnyReferenceManual}
This means, that whitin each module, each method name is unique.

\subsubsection{Shadowing}

Shadowing means that a class method redefines a variable that was already defined as a class member. This means that two variables with the same name exist. The local variable can be accessed via its name, but to access the class member, the programmer needs to write a \code{this} in front of the variable name. One can even go further and redefine a local variable in a nasted blockscope.\\

Consider the following code snippet. It defines a class with a member variable \code{a}. It is initialized with value 2 in the class constructor. In method \code{m}, the variable \code{a} is first of all printed. This will print 2, since the class variable is the only one we are aware of. Next, a variable with the same name is redefined. The class variable is now shadowed by the local variable. Printing a will now print the local variable. To access the class variable, the this-locator is necessary.

\begin{lstlisting}[caption={Complex Shadowing Example}, captionpos=b, label={lst:shadowing}]
    class A {
        constructor () { a := 2; }
        var a: int
        method m() 
        modifies this
        {
            print a;           // 2
            var a: string := "hello";
            print a;           // hello
            print this.a;      // 2
            {
                print a;       // hello
                var a: bool := true;
                print a;       // true
                print this.a;  // 2
            }
        }
    }
\end{lstlisting}

Next, a nested scope is opened. Printing a at first will still yield the local variable. However, in the nested scope, we can redefine a again, shadowing the own local variable. Further calls of a will then print the boolean variable. \texttt{this.a} will still yield 2, even in the nested scope.\\

This behaviour can be summarized with the following three rules:
\begin{itemize}
    \item If the variable was defined locally before its usage, the local definition is significant.
    \item If the variable was not defined locally before its usage, the parent scope is significant.
    \item If a class member is called via the \texttt{this} identifier, the class member is significant.
\end{itemize}

Regarding the implementation, the definition of a symbol could be found using the following method. Prerequisite is though, the scope.AllSymbols returns only those symbols that are defined so far.

\lstset{style=sharpc}
\begin{lstlisting}[caption={Finding Symbol Definition}, captionpos=b, label={lst:findsymbol}]
private Symbol FindDeclaration(Symbol target, Symbol scope)
{
    foreach (Symbol s in scope.AllSymbols)
    {
        if (s.Name == target.Name && s.IsDeclaration)
        {
            return s;
        }
    }
    if (scope.Parent != null)
    {
        return FindDeclaration(target, scope.Parent);
    }
}
\end{lstlisting}

The code above would basically already resolve the \textit{GoTo Definition} problem.

\subsection{Symbol Table}
Was ist eine Symbol tAble?
Inwiefern modifiezeren wir das?
Dafny hta keine, drum selber bauen.

Was erwarten wir von der Symbol table?
Goto Def -> Wo ist die Deklaration?
Rename -> Get all usages with position.
Code Lens -> Get all usages


    








%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Continuous Integration (CI)}
Continuous integration is a verry important part for code quality improvement and colaboration.
Unfortunately, the CI process in our student research project extended to almost the entire semester \cite{sa}. \\

According to our project plan, we wanted to work on open points regarding the CI initially and have completed the theme accordingly for the remaining duration of the bachelor thesis.

\subsubsection{Initial Situation}
We achieved in our client CI that code was analyzed with SonarQube and the build failed if it contained TypeScript errors \cite{sa}.
We did not achieve it within reasonable time headless integration test \cite{sa}. \\

On the server side we reached the build process as well as the dafny tests and our own unit tests \cite{sa}.
Automated integration tests and code analysis by SonarQube remained outstanding \cite{sa}.

\subsubsection{Aimed Solution}
According to our research, a major problem was that the scanner for sonarqube does not support any other languages besides C\# \cite{sonar-supports-only-one-language}.
This means that in addition to C\# in a project, TypeScript (for the client) cannot be analyzed simultaneously.
Furthermore there are also single Java files in Dafny project.
This also led to conflicts in the Sonar analysis in our student research project \cite{sa}. \\

As a simple solution we decided to separate the client (VSCode plugin) and server (Dafny Language Server) into two separate git repositories.
This not only simplifies the CI process but also ensures a generally better and clearer separation. \\

As a result, the client could still be easily analyzed with the previous Sonar scanner.
For the Language Server in C\# a special Sonar scannerfor MSBuild had to be used, which publishes the analysis in a separate SonarCloud project \cite{dev}.
Beside the code from our Lanugae server the whole Dafny project code is now analyzed by sonar.
This can be very helpful for code reviews. \\

The only downside is that the code coverage is not analyzed.
For .NET OpenCover is a very common tool for code coverage analysis.
Unfortunately, it only works on windows and not on our linux CI server \cite{opencover}.
Other tools that works with mono Support .NET Core but not Framework.
During our research we came across monocov \cite{monocov}. This tool would support mono for .NET Framework. Unfortunately this project was archived and has not been supported for almost 10 years \cite{monocov}.

Since we would not gain much added value with sonar code coverage, we decided not to pursue this approach any further. The coverage information is provided by the locally installed IDEs anyway. 
\\

For an easier testability of the CI, we now also used local docker. This allows us to test CI customizations efficiently. See the developer documentation for more details \cite{dev}. \\

The headless integration tests were a bit more tricky.
In consultation with our supervisor, we have removed these tests from the client project and replaced them with own specially written integration tests on the server side.

\subsubsection{2do - Kapitelaufteilung komisch}
Ich hab hier jetzt in der Analyse auch schon die Lösung vorabgegriffen. Sollen wir das splitten? Bricht das nicht den Lesefluss? Evt besprechen.
