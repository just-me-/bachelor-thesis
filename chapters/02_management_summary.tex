\section{Management Summary}
\intnote{non-technical summary von allem mit results}
\label{section:management_summary}
This chapter gives a brief overview of the bachelor thesis at hand.
It his held in a non-technical language to be comprehensive for anyone.

\subsection{Dafny}
\label{section:introduction:dafny}
Dafny is formal programming language.
Within the Dafny code, a developer has the option to state a so called precondition.
This is a fact that must be true at the beginning of the code.
Once the code has been executed, the developer may state a postcondition.
The postcondition is, contrary to the precondition, something that is true at the end of code.
Dafny contains an internal engine to automatically proof postconditions.
This means, given the precondition holds, the code will manipulate data only thus far, so that also the postcondition is valid.

The following code snippet shows an example.
The value \code{a} is given, but it is required to be positive.
This is the precondition.
In the method body, the variable \code{b} is assigned the negative of \code{a}.
We ensure, that \code{b} must be negative, which is the postcondition.
\begin{lstlisting}[language=dafny, caption={Simple Dafny Example}, captionpos=b, label={lst:simpleDafnyExample}]
method Negate(a: int) returns (b: int)
requires a > 0
ensures b < 0
{
    b := -a;
}
\end{lstlisting}
This example is of course trivial.
In a real project, correctness is not always that obvious and computational assistance is welcome.
The main advantage of pre- and postconditions is, that a programmer can be sure that the program is correct.


\subsection{Language Server Protocol}
The language server protocol (LSP) is a specification for communication.
It regulates data exchange between an editor and a so called language server.
The editor is used by the programmer to write code.
The code is then transferred to the language server, using a format specified by the LSP.
The language server is now responsible to analyze the code and provide proper replies to the editor, whenever the editor requests something.
A request could for example be to show information about a variable.
The server has to provide all the necessary information.\\

The separation between the editor and the server has the advantage, that multiple editors can use the same language server.
Support for a programming language like Dafny can thus be achieved for multiple editors by just implementing the language server once.

The most important requests the LSP supports incorporate:
\begin{itemize}
    \item Transfer code to server
    \item Show errors and warnings
    \item Rename a variable
    \item Go to the definition of a variable
    \item Show auto completion suggestions
    \item Perform a refactoring
    \item Show usages of a code item
\end{itemize}
These are features that are commonly used by programmers, independent of the language.
Aside these, Dafny has the option to show a counter example, if a postcondition is violated.
This request is not natively supported by Dafny.
However, custom requests can easily be added to the LSP.
These have to be handled separately within the client though, since the LSP is not automatically displaying the result.


\subsection{Initial Solution}
\label{section:management_summary:initialsolution}
In a previous bachelor thesis by Markus Schaden and Rafael Krucker, a LSP client-server infrastructure for Visual Studio Code was created to support Dafny \cite{ba}.
The plugin was particularly appreciated by the "HSR Correctness Lab" \cite{correctnessLab} to make coding in Dafny easier.
The language server and the Dafny backends were separated into two different components.
This had the disadvantage that they had to communicate over a proprietary interface.
This solution was not optimal, since the Dafny backend was not accessed directly.

In the preceding semester project \cite{sa}, the language server was merged into the Dafny backend, so that the proprietary interface was no longer necessary.
Dafny could be accessed directly by the new software architecture.
Within this bachelor thesis, the work of the existing solution will be continued.


\subsection{Goals}
At HSR, Dafny is taught within the course \textit{Software Engineering}.
Students have to make their first steps in Dafny, using a simple tutorial.
To provide the students with the necessary support, they shall profit by common IDE features like
\begin{itemize}
    \item Error highlighting
    \item Compile and run
    \item Auto completion
\end{itemize}

On the other hand, the plugin shall also be used in a professional environment in the future.
Thus, more advanced features have to be supported.
To facilitate the future development of such features, the codebase shall be refactored to achieve a clean and maintainable state.
This especially involves a clean architectural layout with well-organized dependencies.

Aside a clean architecture, a major goal is the creation of a custom symbol table.
A symbol table contains information about items appearing in the Dafny code.
It shall allow very simple navigation within the Dafny code, for example to locate the declaration of a variable.
Once the symbol table is generated, navigation within the code will be very easy for the language server.
This has the advantage, that many features can be realized with almost trivial logic.
For example, the feature \textit{go to definition} just has to ask the symbol table, where the definition of the symbol is.
Consequently, a well implemented symbol table will also facilitate the development of further features.



\subsection{Results}
%%intro
Within this bachelor thesis, the development of the pre-existing language server and its VSCode client was continued.
Significant improvements could be achieved, which are described in this chapter.

%%Features
The following features are supported by the server:
\begin{itemize}
    \item Syntax highlighting
    \item Verification: highlighting of errors and warnings
    \item Compilation
    \item Show Counter Example
    \item Code Lens
    \item Auto Completion Suggestion
    \item Renaming
    \item Hover Information
\end{itemize}

In comparison to the initial solution, any pre-existing features were improved.

\begin{itemize}
 \item Compilation will no longer start a dedicated Dafny process for compilation. Instead, it will now use a buffered pre-compilate generated by verification and directly call the Dafny's compile method, to generate an executable.
 \item Counter example representation is now much cleaner and easier to perceive.
 \item Verification will now also show warnings.
 \item Verification will no longer just highlight single characters.
 \item Code Lens can now actively be used to preview symbol usages.
 \item Auto completion no longer performs simple pattern matching, but provides exact results.
\end{itemize}
Renaming and hover information could newly be implemented due to the offerings of the symbol table.
The user can now benefit by a plugin, which gained a lot of user experience, but also robustness compared to the initial solution.\\

%%Dev Benefits.
Aside the improvements in features, many internal aspects were also improved.
A component called Dafny translation unit was completely re-visited and simplified.
The component accesses any Dafny functionality.
For example, instead of passing Dafny options as an array of strings, they are now set by
directly accessing Dafny's config class.
Any results provided by the Dafny translation unit are buffered for later re-use at compilation or to create the symbol table.
This makes the implementation significantly more performant.\\

%%ST
The targeted symbol table could be implemented for the most important Dafny language features.
Various challenges had to be accommodated, including the handling of default scopes, default classes, inheritance, external file import or variable hiding.
All of these are properly handled, but in exchange to this quality attribute, not all Dafny language features are supported by the symbol table.
For example, custom datatypes\footnote{for example datatype Tree<T> = Empty | Node(left:Tree,root:T,right:Tree)}, as used in formal programming languages, are not supported.\\

The symbol table opens the option to implement many more features than currently provided.
For example, the LSP offers a highlight request, marking occurrences of a symbol.
Any information required for this feature are already provided by the symbol table.
Thus, adding this feature would be very simple.


%%client
Aside changes in the server, the VSCode client is now as lightweight as possible.
This makes the adaption to other IDE's very simple.
The server is now able to create a symbol table containing any information required for the langue analysis features.
Pre-existing features and algorithms were improved to gain more reliability and a better user experience.



\subsection{Outlook}
While the quality of the features, as well as the general code quality could be massively improved, the project is not in a final state.
Functionality of the project could be improved even further.
Ideas include:
\begin{itemize}
    \item Automatic generation of contracts
    \item Debugging
    \item Create clients for other IDE's.
\end{itemize}
Aside the widening of the feature range, it is definitely necessary to complete the visitor.
The visitor is the component generating an internal symbol table within the language server.
Currently, only the most important Dafny language features are supported.
This was due to the limited time frame of the bachelor thesis.
Nevertheless, the plugin is of a nice quality and can be deployed into the VSCode market place.
Thus, future students can work with it and make their first steps in the Dafny programming language using our plugin.