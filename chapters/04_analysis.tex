\section{Analysis}

\label{section:analysis}
Since this bachelor thesis is a sequel of the preceding semester thesis, work could be directly continued.
Many topics were already analyzed during the semester thesis.
To provide the reader with a comprehensive knowledge base about Dafny and the language server protocol (LSP), some chapters out of the semester thesis will be repeated in the following subsections.
New within this bachelor thesis was the studies of the Dafny-specific compilation process.
It was especially necessary to gain an overview of the existing abstract syntax tree nodes.

\subsection{Language Server Protocol}
\label{section:analysis:lsp}
The language server protocol (LSP) is a JSON-RPC based protocol to communicate between an IDE and a language server \cite{lspWiki}.
In 2016, Microsoft started collaborating with Red Hat and Codenvy to standardize the protocol’s specification \cite{lspWiki}.
The goal of the LSP is to untie the dependency of an IDE with its programming language.
That means, that once a language server is available, the user is free in the choice of the IDE, as long as it offers a client instance that is able to communicate with the server.
The user can then use a variety of features, as long as the language server is capable to handle them.
Those features can for example be
\begin{itemize}
    \item Auto completion
    \item Hover information
    \item Rename
    \item Go to definition
\end{itemize}
and much more. A full list can be found within the LSP specificiation \cite{lspspec}.
Custom requests, for example \textit{compile} or \textit{counterExample} can also be added to the LSP \cite{lspWiki}.
The major advantage of this concept is that the IDE specific plugin can be kept very simple.
The relevant information is delivered by the language server, which is IDE and language independent.
Figure \ref{fig:lspcommunication} from the VSCode extension guide illustrates these benefits \cite{lspextensionguide}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{analysis/lspcommunication.png}
    \caption{Communication Benefit of LSP}
    \label{fig:lspcommunication}
\end{figure}

\subsubsection{Message Types}
The LSP supports three types of messages.
\begin{itemize}
    \item Notification: One-way message, for example for a window notification.
    \item Request: A message that expects a response.
    \item Response: The response to a request.
\end{itemize}
Each message type can be sent from both sides.

\subsubsection{Communication Example}
The basic concept of the LSP is to inform the server about any client action.
For example, when the user is opening a document, the notification \code{textdocument/didOpen} is sent.
The message contains the URI of the opened document, so that the language server can load the source code.
Whenever the user is typing, the notification \code{textDocument/didChange} is sent.
It contains any changes that were made.

The language server on the other hand can verify the opened or changed document and test it for errors.
If errors are found, the server is able to send a \code{textDocument/publishDiagnostics} notification back to the client.
The client may now underline the erroneous code range \cite{lspspec}.
Since the protocol is standardized, the client supporting the LSP is natively able to handle the diagnostics notification, without any actions necessary by a developer.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth/2]{03_lspmsgexample.png}
    \caption{Example Communication}
    \label{fig:lspmsgexample}
\end{figure}

\subsubsection{Message Example}
The following message is a \code{textDocument/publishDiagnostics} notification as it appears in the example above.
It states that on line 4, from character 12 to 17, there is an assertion violation.
Note the JSON-based message format.\\


\begin{lstlisting}[language=json, caption={LSP Message Example}, captionpos=b, label={lst:lspjsonmsg}]
[12:45:29 DBG] Read response body
{
   "jsonrpc":"2.0",
   "method":"textDocument/publishDiagnostics",
   "params":{
      "uri":"file:///D:/[\ddots]/fail1.dfy",
      "diagnostics":[
         {
            "range":{
               "start":{
                  "line":4,
                  "character":12
               },
               "end":{
                  "line":4,
                  "character":17
               }
            },
            "severity":1,
            "code":0,
            "source":"file:///D:/[\ddots]/fail1.dfy",
            "message":"assertion violation"
         }
      ]
   }
}
\end{lstlisting}

\subsubsection{LSP Standard and Individual Extensions}
\intnote{Beschreibung von "Default LSP Sachen" und was wir erweitert haben. Olaf Zimmernmann. Verweis auf Kapitel Custom LSP Messages -
imho reicht das wie es ist. würde da nix erzwingen sonst wirkt es so reingewürgt. steht ja fix in \ref{section:analysis:lsp} + nachher unten in custom lsp msg.}\\

\subsection{OmniSharp}
\label{section:analysis:omnisharp}
To create a language server, a proper LSP implementation is required.
OmniSharp offers support for \Csharp \cite{langserverdotorg} in the form of a NuGet package.
They also offer a language server client that can be used for testing.

\subsubsection{Basic OmniSharp Usage}
Mr. Martin Bj\"orkstr\"om published a comprehensible tutorial about Omnisharp's language server protocol implementation.
The tutorial provides the user with all the required knowledge to set up a language server in \Csharp.
Besides the setup of the server, it also illustrated how to create message handlers, for example for auto completions or document synchronization.

\begin{lstlisting}[language=csharp, caption={LSP Handler Implementation}, captionpos=b, label={lst:lspbasichandler}]
public class AutoCompletion : ICompletionHandler
{
    public Task<CompletionList> Handle(CompletionParams request, CancellationToken cancellationToken)
    {
        throw new NotImplementedException();
    }
}
\end{lstlisting}

Listing \ref{lst:lspbasichandler} illustrates that the user simply has to implement an interface provided by Omnisharp.
Within the \code{request} parameter, all required information is passed to the handler.
For auto completion, this is the file and the cursor position, as well as some context information, how the auto completion event was triggered.
The task of the language server is to figure proper suggestions and return them in the form of a \code{CompletionList} back to the client.\\

Since OmniSharp is open source, we could find all available interfaces and thus all available handlers in their git repository \cite{omnisharpgit}.
Aside the official LSP specification, this collection is very helpful to perceive LSP's possibilities.

\subsubsection{Custom LSP Messages}
\label{chapter:customlspmsg}
The current problem domain does not only require premade LSP messages like auto completions or diagnostics, but also custom requests such as \code{counterExample}, which is Dafny-specific.
Such a message is not natively supported by the language server protocol.
Since no example or documentation could be found on custom messages, Martin Bj\"orkstr\"om was contacted in the OmniSharp Slack channel \cite{omnisharpslack}.
Mr. Bj\"orkstr\"om and his team were able to quickly provide the solution for this issue.\\

The server can simply register custom handlers by implementing the correct interfaces.
The following three items have to be specified:
\begin{itemize}
    \item Name of the message, e.g. \code{counterExample}
    \item Parameter type, e.g. \code{CounterExampleParams}
    \item Response type, e.g. \code{CounterExampleResults}
\end{itemize}


The parameter and response types can be custom classes and more flexibility.
The following skeleton code demonstrates how a custom request handler can be implemented:

\begin{lstlisting}[language=csharp, caption={LSP Handler Implementation}, captionpos=b, label={lst:lspcustomhandler}]
public class CounterExampleParams : IRequest<CounterExampleResults> { [\dots] }
public class CounterExampleResults { [\dots] }

[Serial, Method("counterExample")]
public interface ICounterExampleHandler : IJsonRpcRequestHandler<CounterExampleParams, CounterExampleResults> { }

public class MyHandler : ICounterExampleHandler
{
    public async Task<CounterExampleResults> Handle(CounterExampleParams request, CancellationToken c)
    {
        CounterExampleResults r = await DoSomething(request);
        return r;
    }
}
\end{lstlisting}


\subsection{Visual Studio Code Plugin}
To provide a plugin for Visual Studio code, a custom extension must be programmed.
To get a rough understanding of how to build such an extension, and how to run and debug an own plugin, we already worked through a tutorial during the preceding semester thesis.
In the tutorial "Your First Extension” basic concepts for own plugins were learned \cite{vscode-first-extension}.
Examples for integrating a Language Server were found on the advanced examples page "Extension Guides" \cite{vscode-extensions}. \\

Creating a simple plugin extension, generates the folder structure shown in figure \ref{fig:vs_code_extension_file_structure}.

\begin{figure}[H]
    \centering
    \includegraphics[width=100mm]{analysis/vs_code_extension_file_structure}
    \caption{VSCode Extension File Structure}
    \label{fig:vs_code_extension_file_structure}
\end{figure}
Davor ein Bild. \\
Mehr dazu in Abbildung

The primary components are the two TypeScript files for the extension manifest and the extension source code. \\

Basic plug-in configurations are specified in the manifest.
These include, for example, the name of the plugin, the version,
command registrations and the specification of which files the plugin should be active on. \\

The entry point for the program logic is in the extension source code.
In principle this is a template method.

\begin{lstlisting}[language=typescript, caption={extension.ts}, captionpos=b, label={lst:extension-file}]
import * as vscode from 'vscode';

// This method is called when the extension is activated.
export function activate(context: vscode.ExtensionContext) {
  // Entry point
}
\end{lstlisting}

The logic contained in the client is reduced to the minimum necessary display of
information and the basic registration of events such as the triggering of shortcuts.
The primary logic is handled by the Dafny language server.
To communicate with the language server, the language server must first be started locally as a process by the plugin. \\

With the current version it is assumed that Dafny Language Server is automatically located in the appropriate directory.

Since the Dafny language server is not part of the plugin delivery for the VS Code Marked Place,
this is a problem for the plugin release.
An automated download of the Dafny langauge server is currently missing. \\

One goal of this bachelor thesis is to perform an automated download of the Dafny language server to the local machine of the user.
This ensures the usability of the plugin when published via the VSCode Marked Place.


\subsection{Dafny Language Features}
With regard to the symbol table, the Dafny language had to be studied more in detail.
For example, shadowing describes the existence of multiple variables with the same name, but different visibility scopes.
Concepts like these are highly relevant for the construction of a symbol table.

To be aware of which such concepts are supported - or prohibited - by Dafny, we studied the \textit{Dafny Reference Manual} \cite{dafnyReferenceManual}.
This chapter discusses the most relevant Dafny language concepts with regard to the symbol table.


\subsubsection{Modules}
Dafny code can be organized by modules.
A module is comparable to a namespace in \CsharpWithSpace or C++.
Modules can also be nested.
To use a class defined in another module, the user has three options.
Imagine a method \code{addOne} defined in a module \code{Helpers}.

\begin{lstlisting}[language=dafny, caption={Module Example}, captionpos=b, label={lst:addOneMethod}]
    module Helpers {
        function method addOne(n: nat): nat {
            n + 1
        }
    }
\end{lstlisting}

\begin{itemize}
    \item The user states the module name explicitly in front of the method he wants to call, \linebreak namely \code{Helpers.addOne(5)}.
    \item The user imports the module, for example with \code{import H = Helpers}.
    Afterwards, he may type \code{H.addOne(5)}.
    \item The user imports the module in opened state: \code{import opened Helpers}.
    Now the user is eligible to skip the namespace identifier and can just write \code{addOne(5)}.
\end{itemize}

Importing a module in opened state may cause naming clashes.
This is allowed, but in this case, the locally defined item has always priority over the imported one.
For example, in listing \ref{lst:moduleShadowing}, the assert statement is violated, since the overwritten \code{addOne} has priority \cite{functionVSMethod}.

\begin{lstlisting}[language = dafny, caption={Naming Clash}, captionpos=b, label={lst:moduleShadowing}]
    module Helpers {
        function method addOne(n: nat): nat {
            n + 1
        }
    }
    function addOne(n: nat): nat {
        n + 2
    }

    import opened Helpers
    method m3() {
        assert addOne(5) == 6; //violated
    }

\end{lstlisting}

To import a module defined in another file, the user has to import the file using the expression \code{include "myFile.dfy"}.
This includes all content of the included file into the current file.

\subsubsection{Functions and Methods}
Dafny has two types of methods, or functions respectively.
For a programmer used to \CsharpWithSpace or C++, this concept may be confusing at first, but is very simple:
\begin{itemize}
\item A \textit{method} is what a programmer from \CsharpWithSpace or C++ may be used to.
A sequence of code, accepting some parameters at the beginning and returning some values at the end.
It can be a class member or be in global space.
\item A \textit{function} is more like a mathematical function.
It takes an input and returns a single value.
The function must consist of only one expression.
For example, consider listing \ref{lst:function}.
Furthermore, functions are not compiled into the final executable and may only be used in specification context.
That is, in contracts or assert statements to proof logical correctness prior to compilation \cite{functionVSMethod}.
\item A \textit{function method} is just both at once.
It contains a single expression with a single return, but is also compiled and thus also available in regular context \cite{functionVSMethod}.
\end{itemize}

\begin{lstlisting}[language=dafny, caption={Function Method Example}, captionpos=b, label={lst:function}]
function method min(a:int, b:int) : int
{
    if a < b then a else b
}
\end{lstlisting}

Further concepts include:
\begin{itemize}
\item A \textit{predicate} is just a function returning a bool value.
\item An \textit{inductive} predicate is a predicate calling itself.
\item A \textit{lemma} is a mathematical fact.
It can be called whenever Dafny cannot prove something on its own.
By calling the lemma, the user tells Dafny a fact it can use for its proof.
An example can be found in listing \ref{lst:lemma_example} \cite{dafnyReferenceManual}.
\end{itemize}

\begin{lstlisting}[language=dafny, caption={Lemma}, captionpos=b, label={lst:lemma_example}]
lemma ProvingMultiplication(c: int, m: int)
    ensures c*m == m + (c-1)*m
{}
\end{lstlisting}

\subsubsection{Hiding}
Hiding is when a derived class redefines a member variable of the base class.
Dafny supports inheritance with traits.
A trait is basically an abstract class.
While the trait can define a class variable, any class deriving from it is not allowed to redefine that class variable.
Consider the following example.
The commented code line would cause an error \cite{dafnyReferenceManual}.

\begin{lstlisting}[language=dafny, caption={Hiding}, captionpos=b, label={lst:hiding}]
trait Base {
    var a: int
}

class Sub extends Base {
    constructor() {}
    //var a: int          //Error
}
\end{lstlisting}

This means that this issue does not have to be considered any further with regard to the symbol table.

\subsubsection{Overloading}
Overloading describes the definition of a method with an existing name, but a different signature.
This is, with a different parameter list.
Dafny prohibits this language concept to be able to uniquely identify each method by solely its name \cite{dafnyReferenceManual}.
This means, that within each module, each method name is unique.

\subsubsection{Shadowing}

Shadowing means that a class method redefines a variable that was already previously defined as a class member.
This means that two variables with the same name exist.
The local variable can be accessed via its name, but to access the class member, the programmer needs to write \code{this} in front of the variable name.\\

One can even go further and redefine a local variable in a nested blockscope.
Consider the following code snippet.
It defines a class with a member variable \code{a}.
It is initialized with value $2$ in the class constructor.
In method \code{m}, the variable \code{a} is printed.
This will output $2$, since the class variable is the only one we are aware of.
Next, a variable with the same name is redefined.
The class variable is now shadowed by the local variable.
Printing \code{a} will now print the local variable.
To access the class variable, the this-locator is required.

\begin{lstlisting}[language = dafny, caption={Complex Shadowing Example}, captionpos=b, label={lst:shadowing}]
class A {
    constructor () { a := 2; }
    var a: int
    method m()
    modifies this
    {
        print a;           // 2
        var a: string := "hello";
        print a;           // hello
        print this.a;      // 2
        {
            print a;       // hello
            var a: bool := true;
            print a;       // true
            print this.a;  // 2
        }
    }
}
\end{lstlisting}

In line 11, a nested scope is opened.
Printing \code{a} at first will still yield the local variable.
However, in the nested scope, we can redefine \code{a} again, shadowing the own local variable.
Further calls of \code{a} will then return the boolean value.
\code{this.a} will still yield 2, even inside the nested scope.\\

This behaviour can be summarized with the following three rules:
\begin{itemize}
    \item If the variable was defined locally before its usage, the local definition is significant.
    \item If the variable was not defined locally before its usage, the parent scope is significant.
    \item If a class member is called via the \code{this} identifier, the class member is significant.
\end{itemize}

During analysis of this problem, the following recursive algorithm was created to solve the problem of finding a symbols relevant declaration.

\begin{lstlisting}[language=csharp, caption={Finding Symbol Definition}, captionpos=b, label={lst:findsymbol}]
private Symbol FindDeclaration(Symbol target, Symbol scope)
{
    foreach (Symbol s in scope.AllSymbols)
    {
        if (s.Name == target.Name && s.IsDeclaration)
        {
            return s;
        }
    }
    if (scope.Parent != null)
    {
        return FindDeclaration(target, scope.Parent);
    }
}
\end{lstlisting}
The code had to be adjusted later on, to also respect inherited symbols and to also check inside the default scope.
If all declarations are known, the algorithm does already work for symbols defined after the first usage.

\subsection{Symbol Table}
Whenever source code is compiled into an executable assembly, the first step is to \textit{parse} the code.
The parser of a compiler works with two major concepts.
One of them is the abstract syntax tree (AST), the other is the symbol table.
The AST is a tree, that contains information about the scope of symbols.
Consider the following code snippet.

\begin{lstlisting}[language=dafny, caption={AST Demo Snippet}, captionpos=b, label={lst:astsnipped}]
while(i<5) {
    i := i + 1;
    print i;
}
\end{lstlisting}

The tree segment for this snippet would contain of the while-Statement as the root node.
It then has two branches, one for the condition, and one for the body of the while statement.
The body itself consists of a list of statements.
In the above example, there are two statements.
The first one is an assignment.
The assignment has again a left and a right side.
The right hand side is a binary expression, with the +-operator in between two operands.
The left operand is a name segment expression, and on the right hand side is a literal expression.
The second statement inside the body is a simple print statement with only one item to print, the name segment expression \code{i}.
While these are just three lines of code, the AST is already quite large compared to the code.\\

\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{analysis/DemoASTWithWhileLoop.png}
    \caption{AST Example}
    \label{fig:ast_for_example}
\end{figure}

The tree structure can be well seen in figure \ref{fig:ast_for_example}.
Usually, the AST does not contain information about the type of symbols.
This is where the symbol table comes into play.
The symbol table contains that information and is connected to the AST, for example by the use of a dictionary, linking an AST-node to a symbol table entry.
With the help of the symbol table, it can be figured that the name segment \code{i} is of type int.
The two concepts are strongly coupled.

\subsubsection{Requirements for the symbol table}
To be able to implement the required feature set for this project, the following questions must be answered by the symbol table or the AST, respectively.
\begin{itemize}
    \item Cursor position
    \begin{itemize}
        \item Which name segment (if any) is at the cursor's position?
    \end{itemize}

    \item Go to definition
        \begin{itemize}
            \item Where is the symbol declared?
        \end{itemize}

    \item Code lens
        \begin{itemize}
            \item How often, and where, is a declaration used?
            \item What is stated inside each usage?
        \end{itemize}

    \item Rename
        \begin{itemize}
            \item What are all occurrences of a symbol?
        \end{itemize}

    \item Autocompletion
        \begin{itemize}
            \item Within which scope was the event triggered?
            \item Which declarations are available inside a certain scope?
            \item What is the context; what was just typed before (e.g. a dot or the keyword \code{new})
        \end{itemize}
\end{itemize}


\subsubsection{Dafny Symbols}
In an optimal case, Dafny's own implementation of its symbol table and AST would already contain all of this information.
Unfortunately, this was not the case.
Dafny uses the Coco/R library for its compilation.
This library can generate a source code parser, is thus just generating the AST \cite{coco}.
As one can note regarding figure \ref{fig:ast_for_example}, the AST is not really providing the information required in the list above.
For example, the question where \code{i} is declared is not answered.
Also, some information is not even relevant for the language server.
Within a binary statement, the operand is not of interest for example.\\

The following screenshot shows all available properties and fields of a name segment.
A name segment is just any occurrence of an identifier, for example of a variable or of a method.
\begin{figure}[H]
    \centering
    \includegraphics{analysis/namesegmentbsp.png}
    \caption{Properties and Fields of a NameSegment Expression}
    \label{fig:namesegment}
\end{figure}
While \code{ResolvedExpression} looks like an interesting property, it just points to itself in a regular case, not to the declaration.
Thus, if a name segment is encountered, for example as the right hand side of an assignment, the AST node provided by Dafny does not contain any information about its origin.\\

A better example may be on a higher level.
Regarding the AST-element \code{method},
it contains properties and methods for its body, but not exactly which name segments are declared inside that body.
Also, there is no way to know where that method is used.

\begin{figure}[H]
    \centering
    \includegraphics{analysis/methodbsp.png}
    \caption{Properties and Fields of a Method}
    \label{fig:method}
\end{figure}

To be in control, which information is stored, it was decided to implement an own symbol table / AST combination.
This component will be called \textit{symbol table} throughout this thesis, although it will have a double linked tree structure, as we will see later.


%%%%

\subsection{Visitor}
To generate a symbol table, it is common to use the visitor programming language pattern by Gamma et al \cite{gofBook}.
The pattern is used to navigate through, mostly tree-based, data structures and execute operations while doing so.
The goal of the pattern is to separate the navigation through the data structure, and the operations that take place when visiting.\\

Consider any tree based data structure.
Every node in the tree is supposed to offer an \code{Accept(Visitor v)} method.
This method will accept the visitor, this is, it will execute the visitor's operation on the node itself.
Further, it will also call the \code{accept}-methods of its child nodes.
Thus, a typical implementation of an acceptor would look like this:

\begin{lstlisting}[language=csharp, caption={Example for Accept}, captionpos=b, label={lst:accept}]
public void Accept(Visitor v) {
    v.Visit(this);
    foreach (Node child in this.Children) {
        child.Accept(v);
    }
}
\end{lstlisting}

Note that the navigational aspect - the foreach loop - is inside the accept method, but nothing is told about the visit operation.
The visitor can do whatever it wants with the node, for example print it to the console.
To work with every node that may occur, the visitor must overload the \code{Visit(Node n)} method for each possible subclass of \code{Node}.
Within a tree, these are usually just nodes and leaves.
For a symbol table, possible node types are any kinds of expressions and statements.

A visitor implementation could look like shown below.

\begin{lstlisting}[language=csharp, caption={Example for Visitor}, captionpos=b, label={lst:visitor}]
public class Printer : Visitor {
    public override void Visit(Node n) {
        Console.WriteLine("Node: " + n.ToString());
    }
    public override void Visit(Leaf n) {
        Console.WriteLine("Leaf: " + n.ToString());
    }
}
\end{lstlisting}

\subsection{Dafny Expression and Statement Types}
\label{section:analysis_dafnyASTStuff}
Dafny is a very versatile language.
While it offers common object oriented language features, it also contains formal language features, comparable to languages like Haskell \cite{haskell}.
This results in a humungous variety of AST-nodes.
The most important ones are discussed in this section.\\

Dafny works with three major base classes in its AST.
These are
\begin{itemize}
    \item Expression
    \item Statement
    \item Declaration
\end{itemize}
Aside these, some AST-nodes are separated, such as \code{AssignmentRHS}, which is the right hand side of an assignment.
\code{LocalVariable} is another example for an isolated class, that does not extend any base class.
Why this isolation of certain AST-nodes was made by Dafny could not be evaluated.
Both items are technically expressions and could thus be subclasses of \code{Expression}.

\subsubsection{Expressions}
In this chapter, the most important expression types are explained.
These are also the expressions that were implemented with a dedicated \code{Accept} and \code{Visit}-method.
\begin{itemize}

    \item NameSegment: Any name of a variable or method.
    \item BinaryExpression: An expression with two operands, for example 'plus', or 'less than'.
    \item NegationExpression: The negation of a variable or literal, for example \code{-b}.
    \item UnaryOpExpression: A unary expression, mostly connected to the "not"-Operator, for example \code{!someBoolean}.
    \item ITEExpr: If-then-else expression, such as \code{if a < 0 then -a else a}
    \item ParensExpression: Any expression surrounded by brackets.
    \item AutoGhostIdentifierExpr: A variable declaration can also contain an initial assignment as well. If so, the left hand side of the declaration is a ghost-identifer.
    \item LiteralExpression: Literals like numbers or strings.
    \item ApplySuffix: The brackets after a method. This expression just refers to the brackets, the actual arguments are stored within the method statement.
    \item MaybeFreeExpr: Occurs at ensure-clauses and contains a single subexpression.
    \item FrameExpr: Occurs at the modifies-clause and contains a list of subexpressions.
    \item Formals: Arguments and return values of a method.
\end{itemize}
The reader notes himself, that many expressions contain other subexpressions.

\subsubsection{Statements}
\begin{itemize}
    \item BlockStmt: Anything surrounded by curly brackets.
    \item IfStmt: A classic if-statement. It contains an expression for the condition, a block statement for the then-block, and another, optional if-statement for the else-block.
    \item WhileStmt: A while-loop. It also contains a block statment for its body and an expression for the condition. Aside these, it also contains expressions for the loop invariants, variants and decrease-clauses.
    \item Method: A method contains a block statement for its body. The arguments and return values are stored as formals.
    \item Function: Analog to method.
\end{itemize}

\subsubsection{Declarations}
The following declarations were analyzed:
\begin{itemize}
    \item ModuleDecl: The declaration of a module.
    \item ClassDecl: A class declaration.
    \item Field: A variable member of a class.
    \item Method: A method member of a class.
    \item Function: A function member of a class.
\end{itemize}
These form the most important AST-nodes.
Dafny provides many more of them.
Due to the limited time frame, not all of them could be analyzed.
A benefit of the visitor pattern is, that it can just be implemented once for the base interface \code{IAstNode} with an empty action.
This way, the visitor will just do nothing for nodes that are not supported.

\subsection{Dafny AST Implementation}
During analysis of the Dafny AST, it was noticed that the file \code{DafnyAst.cs} is humungous.
It contains eleven thousand lines of code and a large number of classes.
This is so extensive that even Visual Studio struggles with it and stopped working occasionally on performing refactorings.\\

Since this file and its contained classes will have to be extended by \code{Accept}-methods
to implement the visitor pattern, it was considered to refactor the whole file.\\

Splitting the file into individual class files and dividing it into a separate package would provide much better maintainability.
The following advantages are particularly evident:
\begin{itemize}
    \item Clearer separation
    \item Better overview
    \item Better IDE performance
    \item As a result, less error-prone coding
\end{itemize}

However, there would also be individual disadvantages:
\begin{itemize}
    \item Time-consuming
    \item Inconsistency: Other Dafny files would still be rather large. Refactoring should then be extended.
    \item It is not our responsibility to refactor Dafny code.
    \item Dafny may not want a refactoring at all, because they are used to the current situation.
    \item By swapping out all lines of code, the top level of the git history would be disturbed for git blame.
\end{itemize}

It was decided to not carry out a refactoring.
It would be very time consuming and we would have to extend the refactoring to the whole Dafny project.
Since the time frame of the bachelor thesis is limited, resources should rather be used at the own code segments and the core goals of the bachelor thesis, such as the implementation of the symbol table.
However, refactoring the code of Dafny itself is one of the possible extension points for this project.


\subsection{Supported Features and Needed Improvements / Bisherige FUnktionen und nötige Verbesserungen}
\label{section:analysis:features}


In our existing work we have already realized a number of features.
In the outlook, we have noted what improvements would be appropriate.
This chapter describes the corresponding starting positions and the necessary improvements.
It also describes how we intend to implement these improvements.

\subsubsection{Syntax Highlighting}
The syntax highlighting is realized through a given Dafny grammar file.
Screenshot \ref{fig:analysis_syntax_highlighting} shows how syntax highlighting looks inside Visual Studio Code. \\

As you can see, keywords like method, returns, requires and ensures are marked in purple. Types like int are printed in blue and comments become green. Symbols, such as classes and methods, are displayed in a brownish color. Just these simple rules increase the readability significantly.

\begin{figure}[H]
    \centering
    \includegraphics{analysis/syntax_highlighting}
    \caption{Syntax Highlighting}
    \label{fig:analysis_syntax_highlighting}
\end{figure}

In the current public plugin an update was made to the grammar file \cite{syntax_update}.
Among other things, new keywords are now recognized and visually marked, such as "expect".
This update will be applied to the Dafny grammar file for our plugin version as well.

\subsubsection{Verification}
The verification feature underlines logical errors in the user's code. An example is shown in figure \ref{fig:analysis_verification}.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/verification}
    \caption{Postcondition Violation}
    \label{fig:analysis_verification}
\end{figure}

The logical verification is permanently active. The user just has to type Dafny code and it will be verified. The current version only supports logical errors, not syntax errors.

Whenever an assertion or postcondition violation appears, the code block is underlined in red. The actual postcondition is underlined in yellow. The user can hover over the error to get additional information about the problem. \\

In our thesis we want to extract the syntax errors from the Dafny diagnostic report and show them to the user as well.
todo evt noch kurz genauer schreiben "wie wir das erreichen wollten / planten zu erhalten die info" \\

In addition, it is noticeable that only the curly opening parenthesis is underlined in case of errors concerning methods.
This can easily be overlooked by the user.
For a more distinctive marking, we would now like to underline the complete method block from the opening to the closing parentheses.
With the previous version, this implementation would have been possible only by extensive string parsing of the code - and that with every change to the Dafny code.
With the planned renewal of the symbol table, we automatically have access to the information where the corresponding closing parenthesis of a code block is.

\subsubsection{Compile}
The user has two options to initiate compilation: He can just compile his software or he can additionally run it on a console. The commands are available as hotkeys, in the context menu or via the VSCode command bar. The client will save the document, send its URI, and the server will report back if compilation was successful. If any errors are present in the code, they are reported as a window notification as shown in figure \ref{fig:analysis_compile}. This includes syntax errors. If the compiled program can be run, a PowerShell instance is started directly inside Visual Studio Code.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/compile}
    \caption{User Notification on Compile Errors}
    \label{fig:analysis_compile}
\end{figure}

Dafny allows to specify own arguments for compilation.
We want to offer the plugin user the possibility to specify individual arguments for compilation. \\

On the one hand, extended configuration settings should allow the user to set default values in the plugin, on the other hand the popup box integrated in VS Code can be used for individual argument input for each compile.
todo quellen auf die funktionen von der vs code api

\subsubsection{Counter Example}
To show a counter example, the user has again the choice between a hotkey, the context menu or using the command bar. The counter example is then shown as a VSCode design element. If the user is no longer interested in the counter example, there is another command to hide it. The suppression of the counter model is completely handled inside the client. \\

The example in figure \ref{fig:analysis_counter_example} demonstrates a counter example.
The precondition is commented. Without this requirement, the postcondition can be violated with y = 0.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/counter_example}
    \caption{Demonstration of Counter Examples}
    \label{fig:analysis_counter_example}
\end{figure}

In the current version the counter example is automatically hidden when the Dafny code is changed.
Even if the file is changed in the workspace, the counter example is hidden. \\

New client logic is to be used to store for which files the counter example is to be displayed.
So the counterexample can be displayed to the user again, as soon as he switches back to the original dafny file.
Furthermore an automatic update of the counter example should take place.

If the user inserts additional lines above the display of the counter example.
This shifts the counter example together with the associated code down by the corresponding number of lines. \\

In the future, the Language Server will parse the counterexample.
This allows for the extraction of useful information for the user.
This provides a clear and concise display and increases user friendliness.

\subsubsection{Auto Completion for Identifiers}
Whenever a valid interim result of a Dafny file is sent to the server, the file symbol table is created and buffered.
As an example, if one would have a Dafny code snippet like below, the best and only match would be method m. This is exactly what is suggested for the user as you can see in figure \ref{fig:analysis_completion_1}.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/analysis_completion_1}
    \caption{Auto Completion for Instance of Class C}
    \label{fig:analysis_completion_1}
\end{figure}

In addition auto completion is also able to provide general completion suggestions if one is not typing a word. In this case, just all available symbols are proposed. This is illustrated below in figure \ref{fig:analysis_completion_1}. Please also note that every symbol type (i.e. methods, classes and variables) has its own icon.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/analysis_completion_2}
    \caption{General Suggestions with Symbol Types}
    \label{fig:analysis_completion_2}
\end{figure}

Unfortunately, both implemented versions are neither very reliable nor very performant.
Autocompletion was implemented via string matching.
That means, if the auto completion is called after a dot, the word before the dot is extracted from the source code.
Afterwards the complete symboltable is iterated through and as soon as a symbol with the matching name is found,
it is assumed that this symbol is the originally declared symbol.
If there is a symbol with the same name in different scope areas in a larger project,
the autoocmpletion would no longer function properly. \\

For the general suggestions, simply all the symbols found are suggested.
This means that also symbols are suggested which are not visible in the current scope. \\

As we now receive the originally required information through our new symbol table,
the auto completion is to be rebuilt so that it functions reliably. \\

Symbols can be reliably identified based on the position data in the new symbol table.
Furthermore, the tree structure of the symbol table for auto completion allows us to use only
to suggest the characters in the currently available character in the current scope. \\

In addition, it would be very useful for users if the autocompletion is called after a "new"
keyword and only available classes are automatically listed. This can be achieved by type filtering the symbols.

\subsubsection{Go to Definition}
With the "Go to Definition" feature, a user can simply use the context menu or hit F12 to go to the definition of the used symbol.
In the following figure \ref{fig:analysis_goto_1}, you can see how a user would like to jump to the definition of the method m.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/analysis_goto_1}
    \caption{Go to Definition via Context Menu}
    \label{fig:analysis_goto_1}
\end{figure}

Please note that in the current version, the cursor has to be on the left side of the symbol's keyword. Once pressed, the cursor jumps instantly to the definition of the desired symbol as it is shown in the following figure \ref{fig:analysis_goto_2}.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/analysis_goto_2}
    \caption{Cursor Position after go to Definition}
    \label{fig:analysis_goto_2}
\end{figure}

Go to definition uses a similar logic to autocompletion and is therefore just as unreliable.
The name of the currently selected word is read from the cursor position.
Afterwards the whole symbol table is iterated through - the first symbol with the same name is assumed to be the declaration.
Then the position of this symbol is jumped to. \\

Similar to auto completion, the cursor position can reliably identify the currently selected symbol and the new symbol table can determine the declaration symbol.

\subsubsection{CodeLens}
todo manchmal code lens manchmal codelens \\ code lens ist reichtig

Once a user opens a Dafny file that includes classes, methods or functions, a greyish line shows the reference count to that symbol. As an example, the class C has been instantiated twice and the method m was used once in the following code snippet in figure \ref{fig:analysis_codelens}.

Unfortunately, clicking the grey references is not yet supported. This should open a popup box in which the corresponding uses are shown.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/analysis_codelens}
    \caption{CodeLens Example}
    \label{fig:analysis_codelens}
\end{figure}

The current implementation of CodeLens does not have an optimal runtime. For each symbol found, each symbol in the symbol table is iterated again to compare whether one symbol is a use of the other symbol. This results in a quadratic runtime. \\

With the new symbol table, each symbol knows how often and where it has been used.
Therefore, we only have to iterate through the symbol table once.
Furthermore, the iteration can be limited exclusively to  declarations.


\subsection{Continuous Integration (CI)}


%%%%%%CI%&%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
\intnote{Analyse ist "was haben wir erreicht", Implementation "was haben wir getan, umgesetzt, verbessert", Project Management ist "darum haben wirs getan, für qualität". einverstanden?}

todo machen 

\subsection{Continuous Integration (CI)}
Continuous integration is a very important part for code quality and collaboration.
Unfortunately, setting up the CI process in the preceding semester project\cite{sa} took almost until the end of the project.

According to the project plan, we wanted to resolve all CI-issues at the beginning of the bachelor thesis, so that we can then profit by a supportive workflow.

This chapter describes the initial situation, the desired objectives and the targets achieved regarding CI.

\subsubsection{Initial Situation}
On the client side, code was analyzed with SonarQube by the CI process.
If the code contained any TypeScript errors, an error was thrown and the build failed \cite{sa}.
The end-to-end tests, provided by the pre-existing project could not be integrated, due to their heavy dependencies.\\

On the server side, the project was automatically built by the CI server using \textit{MSBuild}.
Our own unit tests, as well as tests provided by Dafny could as well be automatically executed using the nUnit console runner.
Integration testing and code analysis by SonarQube remained pending \cite{sa}.

\subsubsection{Achieved Solution}
According to our research, a major problem was that the scanner for SonarQube can only analyze one language at a time \cite{sonar-supports-only-one-language}.
This means, that the TypeScript code in the client and the \CsharpWithSpace code in the server cannot be analyzed simultaneously.
Furthermore, in the pre-existing Dafny project, single Java files appear, too.
This led to further conflicts in the Sonar analysis \cite{sa}.\\

As a simple solution, we decided to separate the client (VSCode plugin) and server (Dafny Language Server) into two separate git repositories.
This not only simplifies the CI process but also ensures a generally better and clearer separation. \\

As a result, the client could still be easily analyzed with the previous Sonar scanner.
Regarding the server, a special Sonar scanner for MSBuild had to be installed, which publishes the analysis in a dedicated SonarCloud project \cite{dev}.
The available statistics are very helpful for code reviews.\\



\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{sonarexamaple.png}
    \caption{Example of a Useful Sonar Finding}
    \label{fig:sonarexample}
\end{figure}


Unfortunately, the code coverage by tests is not analyzed.
Searching for an alternative, \textit{OpenCover} was found as a very common tool for code coverage analysis in \Csharp.
Unfortunately, it only runs under Windows  \cite{opencover}.
The CI server bases on Linux, though.
During our research we came across \textit{monocov} \cite{monocov}.
This tool would run under Linux and analyze .NET Framework projects.
Unfortunately, this project was archived and has not been maintained for almost 10 years \cite{monocov}.

Since we would not gain much value with sonar code coverage, we decided not to pursue this approach any further.
The coverage information is provided by the ReSharper extension \textit{dotCover} \cite{dotcover} to the developers.\\

The end-to-end tests base on a lot of dependencies, such as a headless instance of Visual Studio Code.
In consultation with our supervisors, we have removed these tests from the client project and replaced them with own specially written integration tests on the server side.
This can be justified with the client only containing a minimal amount of logic.
Any other logic was moved to the server.

\subsubsection{Docker}
The CI server bases on a Docker distribution.
Docker's lightweight virtualization is ideally suited to run the CI environment.

For an easier testability of the CI, we also installed Docker locally.
This allowed us to resolve CI issues locally and platform-independently (through the Docker Client) in case of problems.
More details are stated in the developer documentation \cite{dev}.\\

Docker also realizes the principle "Cattle, not pets" with docker.  \intnote{hier noch irgend eine cite adden wo das prinzip definiert wird... hab nur grad stackoverflow gefunden, was zitierfähiges wäre nett. sonst wirkt es fast etwas verpsielt für eine BA, nich?}
Instead of having certain package dependencies that need to be updated continuously (pet), a "build, throw away, rebuild" procedure (cattle) is used.
This way, the dependent packages will always be up to date and security patches and the like are automatically deployed.\\

Excluded from this principle are \textit{Node}, \textit{Z3}, \textit{Go}, \textit{Boogie} and \textit{Sonar}.
All of these have to be installed in specific release versions by the CI server.
This is, since Dafny relies on specific deployments of these products.
See the developer documentation for more details \cite{dev}.\\

\subsubsection{2do - Kapitelaufteilung komisch}
Ich hab hier jetzt in der Analyse auch schon die Lösung vorabgegriffen. Sollen wir das splitten? Bricht das nicht den Lesefluss? Evt besprechen.
ja es is iwie komisch. auch unten habenw ir ja noch testing und blabla... kann man evtl so ein CI Kapitel vlt sogar machen? grml.

todo


\subsection{notizen von marcel}

$\rightarrow$ Gedanken zum Updaten sind wichtig. Evt ned alles implementieren aber dokumentieren.... Effizienz. Ned alles neu Builden
wenn in einem File nur ein Zeichen geändert wird auf einer Linie etc. $\rightarrow$ Ausblick.

Und Testing in einem grossen Dafny Project wär evt auch noch ganz nice... ein paar Performance-Tests und so?  \\t: die sind iwo.
Und die dann mit dem Plugin aus der Studienarbeit vergleichen? Und dem alten-alten Plugin? Käme bestimmt jut an.


\subsection{notizen von tom}
gleich nachm schreiben, was mir onch so durch den kopf geht:
\begin{itemize}
    \item Optional: Bildchen für Visitor pattern, wo man sieht (links) Acceptor, macht so den flow, udn rechts 2-3 vidistor wo man sieht, dass die die action machen.
\end{itemize}
