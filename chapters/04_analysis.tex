\section{Analysis}
\label{section:analysis}
Since this thesis is a direct sequel of the preceding semester thesis, work could be directly continued.
However, to provide the reader with a comprehensive knowledge base about Dafny and the language server protocol, some chapters out of the semester thesis will be repeated in the following subsections.
To be able to create the symbol table, more detailed research about Dafny's language feature and its AST element had to be done, which is also described in this chapter.

\subsection{Language Server Protocol}
\label{section:analysis:lsp}
The language server protocol (LSP) is a JSON-RPC based protocol to communicate between an IDE and a language server \cite{dafnyWiki}.
In 2016, Microsoft started collaborating with Red Hat and Codenvy to standardize the protocolâ€™s specification \cite{dafnyWiki}.
The goal of the LSP is to untie the dependency of an IDE with its programming language.
That means, that once a language server is available, the user is free in the choice of his IDE, as long as it offers a client instance that is able to communicate with the server.
The user can then use a variety of features, as long as the language server offers them.
Those features can for example be auto completions, hover information, or go to definition.
Custom message types, for example compile or counterExample can also be added to the LSP \cite{dafnyWiki}.
A big advantage of this is that the IDE specific plugin can be kept very simple.
The relevant information is delivered by the language server, which is IDE and language independent.
Figure \ref{fig:lspcommunication} from the VSCode extension guide illustrates these benefits \cite{lspextensionguide}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{03_lspcommunication.png}
    \caption{Communication Benefit of LSP}
    \label{fig:lspcommunication}
\end{figure}

\subsubsection{Message Types}
The LSP supports three types of messages.
\begin{itemize}
    \item Notification: One-way message, for example for a console log or a window notification.
    \item Request: A message that expects a response.
    \item Response: The response to a request.
\end{itemize}
Each message type can be sent from both sides.

\subsubsection{Communication Example}
The basic concept of the LSP is, that the IDE tells the language server what the user is doing.
These messages are pretty simple, namely \code{textdocument/didOpen} or \code{textDocument/didChange}.
The language server on the other hand can now verify the opened or changed document and test it for errors.
If errors are found, the server can send a \code{textDocument/publishDiagnostics} notification back to the client.
The client may now underline the erroneous code range in red \cite{lspspec}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth/2]{03_lspmsgexample.png}
    \caption{Example Communication}
    \label{fig:lspmsgexample}
\end{figure}

\subsubsection{Message Example}
The following message is a \code{textDocument/publishDiagnostics} notification as it appears in the example above.
It states that on line 4, from character 12 to 17, there is an assertion violation.\\


\begin{lstlisting}[language=json, caption={LSP Message Example}, captionpos=b, label={lst:lspjsonmsg}]
[12:45:29 DBG] Read response body
{
   "jsonrpc":"2.0",
   "method":"textDocument/publishDiagnostics",
   "params":{
      "uri":"file:///D:/[...]/fail1.dfy",
      "diagnostics":[
         {
            "range":{
               "start":{
                  "line":4,
                  "character":12
               },
               "end":{
                  "line":4,
                  "character":17
               }
            },
            "severity":1,
            "code":0,
            "source":"file:///D[\dots]/fail1.dfy",
            "message":"assertion violation"
         }
      ]
   }
}
\end{lstlisting}

\subsubsection{LSP Standard and Individual Extensions}
\intnote{Beschreibung von "Default LSP Sachen" und was wir erweitert haben. Olaf Zimmernmann. Verweis auf Kapitel Custom LSP Messages
}\\

\subsection{OmniSharp}
\label{section:analysis:omnisharp}
To work with the language server protocol, a proper LSP implementation was required.
OmniSharp offers support for \Csharp \cite{langserverdotorg}.
It could be simply installed as a NuGet package.
OmniSharp also offers a language server client that can be used for testing.

\subsubsection{Basic OmniSharp Usage}
\intnote{rewritten}
Mr. artin Bj\"orkstr\"om published a comprehensible tutorial about Omnisharp's language server protocol implementation.
The tutorial provides the user with all the required knowledge to set up a language server in \Csharp.
Besides the setup of the server, it also illustrated how to create message handlers, for example for auto completions or document synchronization.

\begin{lstlisting}[language=csharp, caption={LSP Handler Implementation}, captionpos=b, label={lst:lspbasichandler}]
public class AutoCompletion : ICompletionHandler
{
    public Task<CompletionList> Handle(CompletionParams request, CancellationToken cancellationToken)
    {
        throw new NotImplementedException();
    }
}
\end{lstlisting}

Listing \ref{lst:lspbasichandler} illustrates that the user simply has to implement an interface provided by Omnisharp.
Within the \code{request} parameter, all required information is passed to the handler.
For auto completion, this is the file and the cursor position and some context information, how the auto completion event was triggered.
The task of the langauge server is now to figure proper suggestions and return them in the form of a \code{CompletionList}.\\

Since OmniSharp is open source, we could find all available interfaces and thus all available handlers in their git repository \cite{omnisharpgit}.
This collection is very helpful to perceive LSP's possibilities.

\subsubsection{Custom LSP Messages}
\label{chapter:customlspmsg}
The current problem domain does not only require premade LSP messages like auto completions or diagnostics, but also custom requests such as \code{counterexample}, which is Dafny-specific.
Such a message is not natively supported by the language server protocol.
Since no example or documentation could be found on custom messages, Martin Bj\"orkstr\"om was contacted in the OmniSharp Slack channel \cite{omnisharpslack}.
Mr. Bj\"orkstr\"om and his team were able to provide the solution for this issue.\\

The server can simply register custom handlers, too. The following three items have to be specified:
\begin{itemize}
    \item Name of the message, e.g. "counterExample"
    \item Parameter type, e.g. "CounterExampleParams"
    \item Response type, e.g. "CounterExampleResults"
\end{itemize}


The parameter and response types can be custom classes and allow for maximal flexibility.
The following code skeleton demonstrates how a custom request handler can be implemented:

\begin{lstlisting}[language=csharp, caption={LSP Handler Implementation}, captionpos=b, label={lst:lspcustomhandler}]
public class CounterExampleParams : IRequest<CounterExampleResults> { [\dots] }
public class CounterExampleResults { [\dots] }

[Serial, Method("counterExample")]
public interface ICounterExampleHandler : IJsonRpcRequestHandler<CounterExampleParams, CounterExampleResults> { }

public class MyHandler : ICounterExampleHandler
{
    public async Task<CounterExampleResults> Handle(CounterExampleParams request, CancellationToken c)
    {
        CounterExampleResults r = await DoSomething(request);
        return r;
    }
}
\end{lstlisting}


\subsection{Visual Studio Code Plugin}
todo. seite 16 SA.


\subsection{Dafny Language Features}
With regard to the symbol table, the Dafny language had to be studied more in detail.
For example, shadowing describes the existence of multiple variables with the same name, but different visibility scopes
This is highly relevant for the construction of a symbol table.

To be aware of which such concepts are supported - or prohibited - by Dafny, we studied the Dafny Reference Guide \cite{dafnyReferenceManual}.
This chapter provides the reader with the most relevant concepts with regard to the symbol table.


\subsubsection{Modules}
\intnote{C Sharp hat iwie nie einen Abstand... Latex fix? oben auch backslash dots nicht als drei dots im code snipped.}

Dafny code can be organized by modules.
A module can be compared to a namespace in \Csharp or C++.
Modules can also be nested.
To use a class, method or variable defined in another module, the user has three options.
Imagine a method \code{addOne} defined in a module \code{Helpers}.

\begin{lstlisting}[language=dafny, caption={Module Example}, captionpos=b, label={lst:addOneMethod}]
    module Helpers {
        function method addOne(n: nat): nat {
            n + 1
        }
    }
\end{lstlisting}

\begin{itemize}
    \item The user writes the module name explicitly in front of the method he wants to call, \linebreak namely \code{Helpers.addOne(5)}.
    \item The user imports the module, for example with \code{import H = Helpers}.
    Afterwards, he may type \code{H.addOne(5)}.
    \item The user imports the module in opened state: \code{import opened Helpers}.
    Now the user is eligible to skip the namespace identifier and can just write \code{addOne(5)}.
\end{itemize}

Importing a module in opened state may cause naming clashes.
This is allowed, but in this case, the locally defined item has always priority over the imported one.
For example, in listing \ref{lst:moduleShadowing}, the assert statement is violated, since the overwritten \code{addOne} has priority \cite{functionVSMethod}.

\begin{lstlisting}[language = dafny, caption={Naming Clash}, captionpos=b, label={lst:moduleShadowing}]
    module Helpers {
        function method addOne(n: nat): nat {
            n + 1
        }
    }
    function addOne(n: nat): nat {
        n + 2
    }

    import opened Helpers
    method m3() {
        assert addOne(5) == 6; //violated
    }

\end{lstlisting}

To import a module defined in another file, the user has to import the file using the command \code{include "myFile.dfy"}.
This includes all content of the included file into the current file.

\subsubsection{Functions and Methods}
Dafny has two types of methods, or functions respectively.
For a programmer used to \Csharp or C++, this concept may be confusing at first, but is very simple:
\begin{itemize}
\item A method is what a programmer from \Csharp or C++ may be used to.
A sequence of code, accepting some parameters at the beginning and returning some values at the end.
It can be a class member or be in global space.
\item A function is more like a mathematical function.
It takes an input and returns a single value.
The function may consist of only one expression.
For example, consider listing \ref{lst:function}.
Further, functions are not compiled and may only be used in specification context.
That is, in contracts or assert statements to proof logical correctness \cite{functionVSMethod}.
\item The Function Method is just both at once.
It also contains of a single expression with a single return, but is also compiled and thus also available in regular context \cite{functionVSMethod}.
\end{itemize}

\begin{lstlisting}[caption={Function}, captionpos=b, label={lst:function}]
    function method minFunctionMethod(a:int, b:int):int
    {
        if a<b then a else b
    }
\end{lstlisting}

Further concepts include:
\begin{itemize}
\item A predicate is just a function returning a bool value.
\item An inductive predicate is a predicate calling itself.
\item A lemma is a mathematical fact.
It can be called whenever Dafny cannot prove something on its own.
By calling the lemma, the user tells Dafny a fact it can use for its proof.
An example can be found in listing \ref{lst:lemma_example} \cite{dafnyReferenceManual}.
\end{itemize}

\begin{lstlisting}[caption={Lemma}, captionpos=b, label={lst:lemma_example}]
lemma ProvingMultiplication(c: int, m: int)
    ensures c*m == m + (c-1)*m
{}
\end{lstlisting}

\subsubsection{Hiding}
Hiding is when a derived class redefines a member variable of the base class.
Dafny supports inheritance with traits.
A trait is basically an abstract class.
While the trait can define a class variable, any class deriving from it is not allowed to redefine that class variable.
Consider the following example.
The commented code line would cause an error \cite{dafnyReferenceManual}.

\begin{lstlisting}[caption={Hiding}, captionpos=b, label={lst:hiding}]
trait Base {
    var a: int
}

class Sub extends Base {
    constructor() {}
    //var a: int          //Error
}
\end{lstlisting}

This means that this issue does not have to be considered any further with regard to the symbol table.

\subsubsection{Overloading}
Overloading means defining the same method with a different signature.
This is, with different parameters.
Dafny prohibits this language concept to be able to uniquely identify each method by its name \cite{dafnyReferenceManual}.
This means, that whitin each module, each method name is unique.

\subsubsection{Shadowing}

Shadowing means that a class method redefines a variable that was already defined as a class member.
This means that two variables with the same name exist.
The local variable can be accessed via its name, but to access the class member, the programmer needs to write a \code{this} in front of the variable name.
One can even go further and redefine a local variable in a nasted blockscope.\\

Consider the following code snippet.
It defines a class with a member variable \code{a}.
It is initialized with value 2 in the class constructor.
In method \code{m}, the variable \code{a} is first of all printed.
This will print 2, since the class variable is the only one we are aware of.
Next, a variable with the same name is redefined.
The class variable is now shadowed by the local variable.
Printing a will now print the local variable.
To access the class variable, the this-locator is necessary.

\begin{lstlisting}[language = dafny, caption={Complex Shadowing Example}, captionpos=b, label={lst:shadowing}]
class A {
    constructor () { a := 2; }
    var a: int
    method m()
    modifies this
    {
        print a;           // 2
        var a: string := "hello";
        print a;           // hello
        print this.a;      // 2
        {
            print a;       // hello
            var a: bool := true;
            print a;       // true
            print this.a;  // 2
        }
    }
}
\end{lstlisting}

Next, a nested scope is opened.
Printing a at first will still yield the local variable.
However, in the nested scope, we can redefine a again, shadowing the own local variable.
Further calls of a will then print the boolean variable.
\code{this.a} will still yield 2, even in the nested scope.\\

This behaviour can be summarized with the following three rules:
\begin{itemize}
    \item If the variable was defined locally before its usage, the local definition is significant.
    \item If the variable was not defined locally before its usage, the parent scope is significant.
    \item If a class member is called via the \code{this} identifier, the class member is significant.
\end{itemize}

\intnote{->kapitel implemnentiaotn}
Regarding the implementation, the definition of a symbol could be found using the following method.
Prerequisite is though, the scope.
AllSymbols returns only those symbols that are defined so far.


\begin{lstlisting}[language=csharp, caption={Finding Symbol Definition}, captionpos=b, label={lst:findsymbol}]
private Symbol FindDeclaration(Symbol target, Symbol scope)
{
    foreach (Symbol s in scope.AllSymbols)
    {
        if (s.Name == target.Name && s.IsDeclaration)
        {
            return s;
        }
    }
    if (scope.Parent != null)
    {
        return FindDeclaration(target, scope.Parent);
    }
}
\end{lstlisting}

The code above would basically already resolve the \textit{GoTo Definition} problem.



\intnote{Corbat: @if und dann if als variable ist kein gÃ¼ltiger indentifiyer in dafny.
Noch weitere versprochene doku in der agenda? }\\


\subsection{Symbol Table}
The parser of a compiler works with two major concepts.
One of them is the abstract syntax tree (AST), the other is the symbol table.
The AST is a tree, that contains information about the scope of symbols.
Consider the following code snippet.

\begin{lstlisting}[language=csharp, caption={AST Demo Snippet}, captionpos=b, label={lst:astsnipped}]
while(i<5) {
    i = i + 1;
}
\end{lstlisting}

The tree segment for this snippet would contain of the while-Statement as the root node.
It then has two branches, one for the condition, and one for the body.
The body itself consists of a list of expressions.
In the above example, there is only one expression, namely an assignemnt.
The assignment has again a left and a right side.
The right side is a binary expression, with the +-operator.
Left of the plus is a name segment, and on the right hand side a literal expression.\\

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{03_tree.png}
    \caption{Communication Benefit of LSP}
    \label{fig:tree_for_example}
\end{figure}

Often, the AST doesn not contain information about the type of symbols.
This is where the symbol table comes into play.
The symbol table contains that information and is connected to the AST, for example by the use of a dictionary.
This way, it could be stored that the name segment \code{i} is of type int.
The two concepts are strongly coupled.

\subsubsection{Requirements for the symbol table}
To be able to implement our feature set, the following requirements must be fullfilled by the symbol table.
\begin{itemize}
    \item Cursor Position
    \begin{itemize}
        \item Which name segment is at the cursor's position?
    \end{itemize}

    \item Goto Definition
        \begin{itemize}
            \item Where is the a symbol declared?
        \end{itemize}

    \item Code Lense
        \begin{itemize}
            \item How often, and where, is a declaration used?
        \end{itemize}

    \item Rename
        \begin{itemize}
            \item What are all occurences of a symbol?
        \end{itemize}

    \item Autocompletion
        \begin{itemize}
            \item Which declarations are available in a scope?
        \end{itemize}
\end{itemize}


\subsubsection{Dafny Symbols}
In an optimal case, Dafny's own implementation of its symbol table and AST would already contain all of this information.
Unfortunately, this was not the case.
The following screenshot shows all available properties and fields of a name segment.
A name segment is just any occurence of an identifier, for example of a variable or of a method.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{03_namesegmentfields.png}
    \caption{Properties and Fields of a NameSegment Expression}
    \label{fig:namesegment}
\end{figure}
While \code{ResolvedExpression} looks like an interesting property, it just points to itself in a regular case, not to the declaration or such.
Thus, if a name segment is encountered, for example as the right hand side of an assignment, the name segment does not contain any information about its origin.\\



A better example may be on a higher level.
Let us have a look at the class \code{method}.
It contains properties and methods for it's body, but not exactly which name segments are declared inside that body.
While it has a property \code{EnclosingModule}, it is not stated in what class that method is defined.
The property \code{CompileName} contains information about the enclosing class, but only as a string and is thus of limited use.
Also, there is no way to know where that method is used, which was a prerequisite for the code lens feature.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{03_method.png}
    \caption{Properties and Fields of a Method}
    \label{fig:method}
\end{figure}

Thus, it was decided to implement an own symbol table.
%%%%

\subsection{Visitor}
To be able to generate an own symbol table, it is common to use the visitor programming language pattern by !!REFERENZ von den heinis gang of four balblada!!.
The pattern is used to navigate through, mostly tree-based, data structures and execute operations while doing so.
The goal of the pattern is to separate the navigation through the data structure, and the operations that take place when visiting.\\

Consider a tree based data structure.
Every node in the tree is supposed to offer an \code{Accept(Visitor v)} method.
This method will accept the visitor, this is, it will execute the visitor's operation on the node itself.
Further, it will also call the accept-methods of its child nodes.
Thus, a typical implementation of an accpeptor would look like this:

\begin{lstlisting}[language=csharp, caption={Example for Accept}, captionpos=b, label={lst:accept}]
public void Accept(Visitor v) {
    v.Visit(this);
    foreach (Node child in this.Children) {
        child.Accept(v);
    }
}
\end{lstlisting}

Note that the navigational aspect - the foreach loop - is inside the accept method, but nothing is said about the visit operation.
The visitor can do whatever it wants with the node.
The visitor has overload its \code{Visit} method for each possible node that it is visiting.
Within a tree, these are usually nodes and leafs.
For a symbol table, these are any kinds of expressions and statements.
To complete the example, the visitor could simply print the node.
Its implementation could look like shown below:

\begin{lstlisting}[language=csharp, caption={Example for Visitor}, captionpos=b, label={lst:visitor}]
public class Printer : Visitor {
    public override void Visit(Node n) {
        Console.WriteLine("Node: " + n.ToString());
    }
    public override void Visit(Leaf n) {
        Console.WriteLine("Leaf: " + n.ToString());
    }
}
\end{lstlisting}

\subsection{Dafny Expression and Statement Types}
\label{section:analysis_dafnyASTStuff}
\intnote{ISt dieses Kapitel an einer guten Position? Besser nach Danfy Language Features oder so? Ahh. Ne schon richtig hier. "Platsch" einstieg ersetzen durch "was es so gibt, und warum wichtig (beachten fÃ¼r visitor) etc. Analyse von was es fÃ¼r types gibt und warum. einstieg." }\\


Dafny is a very versatile language.
While it offers common object oriented language features, it also contains formal language features, comparable to more common languages like Haskell.
Thus, it contains numerous AST-nodes.
The most important ones shall be discussed within this section.\\

Dafny works with three major base clases in its AST.
These are
\begin{itemize}
    \item Expression
    \item Statement
    \item Declaration
\end{itemize}
Aside these, some AST-nodes are separate, such as \code{AssignmentRHS}, which is the right side of an assignment.
\code{LocalVariable} is another example for an isolated class, that does not extend any base class. 
hy this decision was made by Dafny could not be evaluated.
Both items are actually expressions and could technically be subclasses of \code{Expression}.

\subsubsection{Expressions}
In this chapter, the most important expression types are explained:
\begin{itemize}

    \item NameSegment: Any name of a variable or method.
    \item BinaryExpression: An expression with two operands, for example 'plus', or 'less than'.
    \item NegationExpression: Just the negation of a variable or literal, for example \code{-b}.
    \item UnaryOpExpression: A unary expression, mostly connected to the "not"-Operator, for example \code{!someBoolean}.
    \item ITEExpr: If-then-else expression, such as \code{if a<0 then -a else a}
    \item ParensExpression: Any expression surrounded by brackets.
    \item AutoGhostIdentifierExpr: If a variable declaration also contains an assignment as well, the left hand side of the declaration is a ghost-identifer.
    \item LiteralExpression: Literals like numbers or strings.
    \item ApplySuffix: The brackets after a method. This expression just refers to the brackets, the actual arguments are stored within the method expression.
    \item MaybeFreeExpr: Occurs at ensure-clauses and just contains a subexpression.
    \item FrameExpr: Occurs at the modifies-clause and just contains a list of subexpressions.
\end{itemize}
The reader notes himself, that many expressions contain of other subexpressions.

\subsubsection{Statements}
\begin{itemize}
    \item BlockStmt: Anything surrounded by curly brackets.
    \item IfStmt: A classic if-statement. It contains an expression for the condition, a blockstatment for the then-block, and another, optional if-statement for the else-block.
    \item WhileStmt: A while-loop. It also contains a blockstatment for its body and an expression for the condition. Aside these, it also contains expressions for the loop invariants and decrease-clasues.
    \item Method: The method contains a block statement for its body. The arguments and return values are stored as \code{Formals}.
    \item Function: Analog to method.
\end{itemize}

\subsubsection{Declarations}
The following declarations were analyzed:
\begin{itemize}
    \item ModuleDecl: A module declaration
    \item Class: A class declaration
    \item Field: A variable member of a class
    \item Method: A method member of a class
    \item Function: A function member of a class
\end{itemize}



\subsection{Dafny AST Implementation}
During analysis of the Dafny AST, it was noticed that the file \code{DafnyAst.cs} is huge.
It contains eleven thousand lines of code and a large number of classes.
This is so extensive that even Visual Studio struggles with it and crashed occasionally on performing autocompletions.\\

Since this file and its contained classes will have to be extended by \code{Accept}-methods
to implement a the visitor pattern, it was considered to refactor the whole file.\\

Splitting the file into individual class files and dividing it into a separate packages would provide a mutch better maintainability.
The following advantages are particularly evident:
\begin{itemize}
    \item Clearer separation
    \item Better overview
    \item Better IDE performance
    \item As a result, less error-prone coding
\end{itemize}

However, there would also be individual disadvantages:
\begin{itemize}
    \item Time-consuming
    \item Inconsistency: Any other Dafny files would still be rather large. Refactoring should then be extended
    \item The maintainers of Dafny may not want a refactored style at all, because they are used to the current situation
    \item By swapping out all lines of code, the top level of the git history would be disturbed for git blame
\end{itemize}

It was decided not to carry out a refactoring.
It would be very time consuming and we would have to extend the refactoring to the whole Dafny project.
Since the time frame of the bachelor thesis is limited, ressources should rather be used at the own code segments and the core concept of the bachelor thesis, such as the implementation of the symbol table.
However, refactoring the code of Dafny itself is one of the possible outlooks of this project.



%%%%%%%%%%%%%%%%%%%%%%%



\subsection{Continuous Integration (CI)}
Continuous integration is a very important part for code quality and colaboration.
Unfortunately, setting up the CI process in the preceding project\cite{sa} took almost until the end of the project stage.

According to our project plan, we wanted to resolve all CI-issues at the beginning of the bachelor thesis, so that we can then profit by a supportive workflow.

This chapter describes the initial situation, the desired objectives and the targets achieved.

\subsubsection{Initial Situation}
On the client side, code was analyzed with SonarQube durring the CI process.
If the code contained TypeScript errors, the build failed \cite{sa}.
The end-to-end tests, provided by the preceding bachelor thesis\cite{ba} could not be integrated until the end of the project, due to their heavy dependencies.\\

On the server side, the project was automatically built by the CI server.
Our own unit tests, as well as tests provided by Dafny could as well be automatically exectued.
Integration testing and code analysis by SonarQube remained pending \cite{sa}.

\subsubsection{Targeted Solution - Achieved Solution}
According to our research, a major problem was that the scanner for SonarQube can only analyze one language at a time \cite{sonar-supports-only-one-language}.
This means, that the TypeScript code in the client and the \Csharp code in the server cannot be analyzed simultaneously.
Furthermore, in the preexisting Dafny project, there are also single Java files.
This led to further conflicts in the Sonar analysis \cite{sa}.\\

As a simple solution, we decided to separate the client (VSCode plugin) and server (Dafny Language Server) into two separate git repositories.
This not only simplifies the CI process but also ensures a generally better and clearer separation \\

As a result, the client could still be easily analyzed with the previous Sonar scanner.
Regarding the server, a special Sonar scanner for MSBuild had to be installed, which publishes the analysis in a dedicated SonarCloud project \cite{dev}.
The available statistics are very helpful for code reviews.\\

The only downside is that the code coverage is not analyzed.
Searching for an alternative, \textit{OpenCover} was found as a very common tool for code coverage analysis in \Csharp.
Unfortunately, it only runs under Windows  \cite{opencover}.
The CI server bases on Linux, though.
During our research we came across monocov \cite{monocov}.
This tool would run under Linux and analyze .NET Framework projects.
Unfortunately this project was archived and has not been supported for almost 10 years \cite{monocov}.

Since we would not gain much value with sonar code coverage, we decided not to pursue this approach any further.
The coverage information is provided by the locally installed IDEs anyway.\\

The end-to-end tests base on a lot of dependencies, such as a headless instance of Visual Studio Code.
In consultation with our supervisor, we have removed these tests from the client project and replaced them with own specially written integration tests on the server side.

\subsubsection{Docker}
The CI server bases on a Docker distribution.
Docker's lightweight virtualization is ideally suited to run the CI environment.

For an easier testability of the CI, we also installed Docker locally.
This allowed us to resolve CI issues locally and platform-independently (through the Docker Client) in case of problems.
See the developer documentation for more details \cite{dev}.\\

Docker also realizes the priciple "Cattle, not pets" with docker.  \intnote{hier noch irgend eine cite adden wo das prinzip definiert wird... hab nur grad stackoverflow gefunden, was zitierfÃ¤higes wÃ¤re nett. sonst wirkt es fast etwas kindisch/verpsielt fÃ¼rÃ¼ eine BA.}
Instead of having certain package dependencies that need to be updated continuously (pet), a "build, throw away, rebuild" procedure (cattle) is used.
This way, the dependent packages will always be up to date and security patches and the like are automatically deployed.\\

Excluded from this principle are Node, Z3, Go, Boogie and Sonar.
All of these have to be installed in specific release versions within the CI server.
This is, since Dafny relies on specific deployments of these products. See the developer documentation for more details \cite{dev}. \\
\intnote{wtf ist go, und node und sonar ist doch egal werlche version oder?}

\subsubsection{2do - Kapitelaufteilung komisch}
Ich hab hier jetzt in der Analyse auch schon die LÃ¶sung vorabgegriffen. Sollen wir das splitten? Bricht das nicht den Lesefluss? Evt besprechen.
ja es is iwie komisch. auch unten habenw ir ja noch testing und blabla... kann man evtl so ein CI Kapitel vlt sogar machen? grml.

todo


\subsection{notizen von marcel}

$\rightarrow$ Gedanken zum Updaten sind wichtig. Evt ned alles implementieren aber dokumentieren.... Effizienz. Ned alles neu Builden
wenn in einem File nur ein Zeichen geÃ¤ndert wird auf einer Linie etc. $\rightarrow$ Ausblick.

Und Testing in einem grossen Dafny Project wÃ¤r evt auch noch ganz nice... ein paar Performance-Tests und so?
Und die dann mit dem Plugin aus der Studienarbeit vergleichen? Und dem alten-alten Plugin? KÃ¤me bestimmt jut an.


\subsection{notizen von tom}
gleich nachm schreiben, was mir onch so durch den kopf geht:
\begin{itemize}
    \item Visitor Pattern braucht auch olaf und guido nicht jeden tag. Kommen die draus? WÃ¤re nicht ein schema-bildchen noch gut, aka 'kuck hier links, der accept sagt wo ich durch muss, udn kuck hier rechts, der visitor sagt was getan wird. oder irgend sowas, ka.
    \item expression list und co total random... halt brutal unvollstÃ¤ndig etc pp. erklÃ¤ren, warum das unvollstÃ¤ndig ist.
    \item SymbolTable, AST, connected, blabla... ist das gut genug? Corbat hat sehr viel Ahnung davon und mein Halbwissen ist da ein bisschen gefÃ¤hrlich, das gibt dann ja total schelchten eindruck.
    \item Lanague Feautres: am anfang noch spezifisch schreiben, dass wir jetzt nur auf den shit eingehen, der fÃ¼r symboltable relevant ist, aka wo kÃ¶nnten doppelte namen vorkommen.
    \item Ist der flow eig klar? wir mÃ¼ssen ne symbolt able machen, $\Rightarrow$ was hat n dafny da Ã¼berhaupt so, $\Rightarrow$ wie machen wir es, $\Rightarrow$ visitor is gut fÃ¼r sowas $\Rightarrow$ muss dies und das visitien.
\end{itemize}
