\section{Analysis}
\label{section:analysis}
Since this bachelor thesis is a sequel of the preceding semester thesis, work could be directly continued.
Many topics were already analyzed during the semester thesis.
To provide the reader with a comprehensive knowledge base about Dafny and the language server protocol (LSP), some chapters out of the semester thesis will be repeated in the following subsections.
New within this bachelor thesis was the studies of the Dafny-specific compilation process.
It was especially necessary to gain an overview of the existing abstract syntax tree nodes.

\subsection{Language Server Protocol}
\label{section:analysis:lsp}
The language server protocol (LSP) is a JSON-RPC based protocol to communicate between an IDE and a language server \cite{lspWiki}.
In 2016, Microsoft started collaborating with Red Hat and Codenvy to standardize the protocol’s specification \cite{lspWiki}.
The goal of the LSP is to untie the dependency of an IDE with its programming language.
That means, that once a language server is available, the user is free in the choice of the IDE, as long as it offers a client instance that is able to communicate with the server.
The user can then use a variety of features, as long as the language server is capable to handle them.
Those features can for example be
\begin{itemize}
    \item auto completion
    \item hover information
    \item rename
    \item go to definition
\end{itemize}
and much more. A full list can be found within the LSP specificiation \cite{lspspec}.
Custom requests, for example \textit{compile} or \textit{counterExample} can also be added to the LSP \cite{lspWiki}.
The major advantage of this concept is that the IDE specific plugin can be kept very simple.
The relevant information is delivered by the language server, which is IDE and language independent.
Figure \ref{fig:lspcommunication} from the VSCode extension guide illustrates these benefits \cite{lspextensionguide}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{03_lspcommunication.png}
    \caption{Communication Benefit of LSP}
    \label{fig:lspcommunication}
\end{figure}

\subsubsection{Message Types}
The LSP supports three types of messages.
\begin{itemize}
    \item Notification: One-way message, for example for a window notification.
    \item Request: A message that expects a response.
    \item Response: The response to a request.
\end{itemize}
Each message type can be sent from both sides.

\subsubsection{Communication Example}
The basic concept of the LSP is to inform the server about any client action.
For example, when the user is opening a document, the notification \code{textdocument/didOpen} is sent.
The message contains the URI of the opened document, so that the language server can load the source code.
Whenever the user is typing, the notification \code{textDocument/didChange} is sent.
It contains any changes that were made.

The language server on the other hand can verify the opened or changed document and test it for errors.
If errors are found, the server is able to send a \code{textDocument/publishDiagnostics} notification back to the client.
The client may now underline the erroneous code range \cite{lspspec}.
Since the protocol is standardized, the client supporting the LSP is natively able to handle the diagnostics notification, without any actions necessary by a developer.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth/2]{03_lspmsgexample.png}
    \caption{Example Communication}
    \label{fig:lspmsgexample}
\end{figure}

\subsubsection{Message Example}
The following message is a \code{textDocument/publishDiagnostics} notification as it appears in the example above.
It states that on line 4, from character 12 to 17, there is an assertion violation.
Note the JSON-based message format.\\


\begin{lstlisting}[language=json, caption={LSP Message Example}, captionpos=b, label={lst:lspjsonmsg}]
[12:45:29 DBG] Read response body
{
   "jsonrpc":"2.0",
   "method":"textDocument/publishDiagnostics",
   "params":{
      "uri":"file:///D:/[\ddots]/fail1.dfy",
      "diagnostics":[
         {
            "range":{
               "start":{
                  "line":4,
                  "character":12
               },
               "end":{
                  "line":4,
                  "character":17
               }
            },
            "severity":1,
            "code":0,
            "source":"file:///D:/[\ddots]/fail1.dfy",
            "message":"assertion violation"
         }
      ]
   }
}
\end{lstlisting}

\subsubsection{LSP Standard and Individual Extensions}
\intnote{Beschreibung von "Default LSP Sachen" und was wir erweitert haben. Olaf Zimmernmann. Verweis auf Kapitel Custom LSP Messages - ist gut so oder?}\\

\subsection{OmniSharp}
\label{section:analysis:omnisharp}
To create a language server, a proper LSP implementation is required.
OmniSharp offers support for \Csharp \cite{langserverdotorg} in the form of a NuGet package.
They also offer a language server client that can be used for testing.

\subsubsection{Basic OmniSharp Usage}
Mr. Martin Bj\"orkstr\"om published a comprehensible tutorial about Omnisharp's language server protocol implementation.
The tutorial provides the user with all the required knowledge to set up a language server in \Csharp.
Besides the setup of the server, it also illustrated how to create message handlers, for example for auto completions or document synchronization.

\begin{lstlisting}[language=csharp, caption={LSP Handler Implementation}, captionpos=b, label={lst:lspbasichandler}]
public class AutoCompletion : ICompletionHandler
{
    public Task<CompletionList> Handle(CompletionParams request, CancellationToken cancellationToken)
    {
        throw new NotImplementedException();
    }
}
\end{lstlisting}

Listing \ref{lst:lspbasichandler} illustrates that the user simply has to implement an interface provided by Omnisharp.
Within the \code{request} parameter, all required information is passed to the handler.
For auto completion, this is the file and the cursor position, as well as some context information, how the auto completion event was triggered.
The task of the language server is to figure proper suggestions and return them in the form of a \code{CompletionList} back to the client.\\

Since OmniSharp is open source, we could find all available interfaces and thus all available handlers in their git repository \cite{omnisharpgit}.
Aside the official LSP specification, this collection is very helpful to perceive LSP's possibilities.

\subsubsection{Custom LSP Messages}
\label{chapter:customlspmsg}
The current problem domain does not only require premade LSP messages like auto completions or diagnostics, but also custom requests such as \code{counterExample}, which is Dafny-specific.
Such a message is not natively supported by the language server protocol.
Since no example or documentation could be found on custom messages, Martin Bj\"orkstr\"om was contacted in the OmniSharp Slack channel \cite{omnisharpslack}.
Mr. Bj\"orkstr\"om and his team were able to quickly provide the solution for this issue.\\

The server can simply register custom handlers by implementing the correct interfaces.
The following three items have to be specified:
\begin{itemize}
    \item Name of the message, e.g. \code{counterExample}
    \item Parameter type, e.g. \code{CounterExampleParams}
    \item Response type, e.g. \code{CounterExampleResults}
\end{itemize}


The parameter and response types can be custom classes and allow for maximal flexibility. \intnote{allow for - is that correct english?}
The following skeleton code demonstrates how a custom request handler can be implemented:

\begin{lstlisting}[language=csharp, caption={LSP Handler Implementation}, captionpos=b, label={lst:lspcustomhandler}]
public class CounterExampleParams : IRequest<CounterExampleResults> { [\dots] }
public class CounterExampleResults { [\dots] }

[Serial, Method("counterExample")]
public interface ICounterExampleHandler : IJsonRpcRequestHandler<CounterExampleParams, CounterExampleResults> { }

public class MyHandler : ICounterExampleHandler
{
    public async Task<CounterExampleResults> Handle(CounterExampleParams request, CancellationToken c)
    {
        CounterExampleResults r = await DoSomething(request);
        return r;
    }
}
\end{lstlisting}


\subsection{Visual Studio Code Plugin}
\intnote{todo. seite 16 SA.}


\subsection{Dafny Language Features}
With regard to the symbol table, the Dafny language had to be studied more in detail.
For example, shadowing describes the existence of multiple variables with the same name, but different visibility scopes.
Concepts like these are highly relevant for the construction of a symbol table.

To be aware of which such concepts are supported - or prohibited - by Dafny, we studied the \textit{Dafny Reference Manual} \cite{dafnyReferenceManual}.
This chapter discusses the most relevant Dafny language concepts with regard to the symbol table.


\subsubsection{Modules}
Dafny code can be organized by modules.
A module is comparable to a namespace in \CsharpWithSpace or C++.
Modules can also be nested.
To use a class defined in another module, the user has three options.
Imagine a method \code{addOne} defined in a module \code{Helpers}.

\begin{lstlisting}[language=dafny, caption={Module Example}, captionpos=b, label={lst:addOneMethod}]
    module Helpers {
        function method addOne(n: nat): nat {
            n + 1
        }
    }
\end{lstlisting}

\begin{itemize}
    \item The user states the module name explicitly in front of the method he wants to call, \linebreak namely \code{Helpers.addOne(5)}.
    \item The user imports the module, for example with \code{import H = Helpers}.
    Afterwards, he may type \code{H.addOne(5)}.
    \item The user imports the module in opened state: \code{import opened Helpers}.
    Now the user is eligible to skip the namespace identifier and can just write \code{addOne(5)}.
\end{itemize}

Importing a module in opened state may cause naming clashes.
This is allowed, but in this case, the locally defined item has always priority over the imported one.
For example, in listing \ref{lst:moduleShadowing}, the assert statement is violated, since the overwritten \code{addOne} has priority \cite{functionVSMethod}.

\begin{lstlisting}[language = dafny, caption={Naming Clash}, captionpos=b, label={lst:moduleShadowing}]
    module Helpers {
        function method addOne(n: nat): nat {
            n + 1
        }
    }
    function addOne(n: nat): nat {
        n + 2
    }

    import opened Helpers
    method m3() {
        assert addOne(5) == 6; //violated
    }

\end{lstlisting}

To import a module defined in another file, the user has to import the file using the expression \code{include "myFile.dfy"}.
This includes all content of the included file into the current file.

\subsubsection{Functions and Methods}
Dafny has two types of methods, or functions respectively.
For a programmer used to \CsharpWithSpace or C++, this concept may be confusing at first, but is very simple:
\begin{itemize}
\item A \textit{method} is what a programmer from \CsharpWithSpace or C++ may be used to.
A sequence of code, accepting some parameters at the beginning and returning some values at the end.
It can be a class member or be in global space.
\item A \textit{function} is more like a mathematical function.
It takes an input and returns a single value.
The function must consist of only one expression.
For example, consider listing \ref{lst:function}.
Furthermore, functions are not compiled into the final executable and may only be used in specification context.
That is, in contracts or assert statements to proof logical correctness prior to compilation \cite{functionVSMethod}.
\item A \textit{function method} is just both at once.
It contains a single expression with a single return, but is also compiled and thus also available in regular context \cite{functionVSMethod}.
\end{itemize}

\begin{lstlisting}[language=dafny, caption={Function Method Example}, captionpos=b, label={lst:function}]
function method min(a:int, b:int) : int
{
    if a < b then a else b
}
\end{lstlisting}

Further concepts include:
\begin{itemize}
\item A \textit{predicate} is just a function returning a bool value.
\item An \textit{inductive} predicate is a predicate calling itself.
\item A \textit{lemma} is a mathematical fact.
It can be called whenever Dafny cannot prove something on its own.
By calling the lemma, the user tells Dafny a fact it can use for its proof.
An example can be found in listing \ref{lst:lemma_example} \cite{dafnyReferenceManual}.
\end{itemize}

\begin{lstlisting}[language=dafny, caption={Lemma}, captionpos=b, label={lst:lemma_example}]
lemma ProvingMultiplication(c: int, m: int)
    ensures c*m == m + (c-1)*m
{}
\end{lstlisting}

\subsubsection{Hiding}
Hiding is when a derived class redefines a member variable of the base class.
Dafny supports inheritance with traits.
A trait is basically an abstract class.
While the trait can define a class variable, any class deriving from it is not allowed to redefine that class variable.
Consider the following example.
The commented code line would cause an error \cite{dafnyReferenceManual}.

\begin{lstlisting}[caption={Hiding}, captionpos=b, label={lst:hiding}]
trait Base {
    var a: int
}

class Sub extends Base {
    constructor() {}
    //var a: int          //Error
}
\end{lstlisting}

This means that this issue does not have to be considered any further with regard to the symbol table.

\subsubsection{Overloading}
Overloading describes the definition of a method with an existing name, but a different signature.
This is, with a different parameter list.
Dafny prohibits this language concept to be able to uniquely identify each method by solely its name \cite{dafnyReferenceManual}.
This means, that within each module, each method name is unique.

\subsubsection{Shadowing}

Shadowing means that a class method redefines a variable that was already previously defined as a class member.
This means that two variables with the same name exist.
The local variable can be accessed via its name, but to access the class member, the programmer needs to write \code{this} in front of the variable name.\\

One can even go further and redefine a local variable in a nested blockscope.
Consider the following code snippet.
It defines a class with a member variable \code{a}.
It is initialized with value $2$ in the class constructor.
In method \code{m}, the variable \code{a} is printed.
This will output $2$, since the class variable is the only one we are aware of.
Next, a variable with the same name is redefined.
The class variable is now shadowed by the local variable.
Printing \code{a} will now print the local variable.
To access the class variable, the this-locator is required.

\begin{lstlisting}[language = dafny, caption={Complex Shadowing Example}, captionpos=b, label={lst:shadowing}]
class A {
    constructor () { a := 2; }
    var a: int
    method m()
    modifies this
    {
        print a;           // 2
        var a: string := "hello";
        print a;           // hello
        print this.a;      // 2
        {
            print a;       // hello
            var a: bool := true;
            print a;       // true
            print this.a;  // 2
        }
    }
}
\end{lstlisting}

In line 11, a nested scope is opened.
Printing \code{a} at first will still yield the local variable.
However, in the nested scope, we can redefine \code{a} again, shadowing the own local variable.
Further calls of \code{a} will then return the boolean value.
\code{this.a} will still yield 2, even inside the nested scope.\\

This behaviour can be summarized with the following three rules:
\begin{itemize}
    \item If the variable was defined locally before its usage, the local definition is significant.
    \item If the variable was not defined locally before its usage, the parent scope is significant.
    \item If a class member is called via the \code{this} identifier, the class member is significant.
\end{itemize}

During analysis of this problem, the following recursive algorithm was created to solve the problem of finding a symbols relevant declaration.
\intnote{ist code - ja. ist aber ein ANALYSE wie man das problem lösen kann - gemacht wurde es dann ja sowieso anders. kann man also imho sehr wohl hier lassen}

\begin{lstlisting}[language=csharp, caption={Finding Symbol Definition}, captionpos=b, label={lst:findsymbol}]
private Symbol FindDeclaration(Symbol target, Symbol scope)
{
    foreach (Symbol s in scope.AllSymbols)
    {
        if (s.Name == target.Name && s.IsDeclaration)
        {
            return s;
        }
    }
    if (scope.Parent != null)
    {
        return FindDeclaration(target, scope.Parent);
    }
}
\end{lstlisting}
The code had to be adjusted later on, to also respect inherited symbols and to also check inside the default scope.
If all declarations are known, the algorithm does already work for symbols defined after the first usage.


\intnote{Corbat: @if und dann if als variable ist kein gültiger indentifiyer in dafny.
Noch weitere versprochene doku in der agenda?
findest du das relevant?
interessiert mich jetzt nicht so primär, dass ich kein if identifier nutzen darf. will er das wirklich hören? :O }\\


\subsection{Symbol Table}
Whenever source code is compiled into an executable assembly, the first step is to \textit{parse} the code.
The parser of a compiler works with two major concepts.
One of them is the abstract syntax tree (AST), the other is the symbol table.
The AST is a tree, that contains information about the scope of symbols.
Consider the following code snippet.

\begin{lstlisting}[language=dafny, caption={AST Demo Snippet}, captionpos=b, label={lst:astsnipped}]
while(i<5) {
    i := i + 1;
    print i;
}
\end{lstlisting}

The tree segment for this snippet would contain of the while-Statement as the root node.
It then has two branches, one for the condition, and one for the body of the while statement.
The body itself consists of a list of statements.
In the above example, there are two statements.
The first one is an assignment.
The assignment has again a left and a right side.
The right hand side is a binary expression, with the +-operator in between two operands.
The left operand is a name segment expression, and on the right hand side is a literal expression.
The second statement inside the body is a simple print statement with only one item to print, the name segment expression \code{i}.
While these are just three lines of code, the AST is already quite large compared to the code.\\

\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{analysis/DemoASTWithWhileLoop.png}
    \caption{AST Example}
    \label{fig:ast_for_example}
\end{figure}

The tree structure can be well seen in figure \ref{fig:tree_for_example}.
Usually, the AST does not contain information about the type of symbols.
This is where the symbol table comes into play.
The symbol table contains that information and is connected to the AST, for example by the use of a dictionary, linking an AST-node to a symbol table entry.
With the help of the symbol table, it can be figured that the name segment \code{i} is of type int.
The two concepts are strongly coupled.

\subsubsection{Requirements for the symbol table}
To be able to implement the required feature set for this project, the following questions must be answered by the symbol table or the AST, respectively.
\begin{itemize}
    \item Cursor position
    \begin{itemize}
        \item Which name segment (if any) is at the cursor's position?
    \end{itemize}

    \item Go to definition
        \begin{itemize}
            \item Where is the symbol declared?
        \end{itemize}

    \item Code lens
        \begin{itemize}
            \item How often, and where, is a declaration used?
            \item What is stated inside each usage?
        \end{itemize}

    \item Rename
        \begin{itemize}
            \item What are all occurrences of a symbol?
        \end{itemize}

    \item Autocompletion
        \begin{itemize}
            \item Within which scope was the event triggered?
            \item Which declarations are available inside a certain scope?
            \item What is the context; what was just typed before (e.g. a dot or the keyword \code{new})
        \end{itemize}
\end{itemize}


\subsubsection{Dafny Symbols}
In an optimal case, Dafny's own implementation of its symbol table and AST would already contain all of this information.
Unfortunately, this was not the case.
Dafny uses the Coco/R library for its compilation.
This library can generate a source code parser, is thus just generating the AST \cite{coco}.
As one can note regarding figure \ref{fig:ast_for_example}, the AST is not really providing the information required in the list above.
For example, the question where \code{i} is declared is not answered.
Also, some information is not even relevant for the language server.
Within a binary statement, the operand is not of interest for example.\\

The following screenshot shows all available properties and fields of a name segment.
A name segment is just any occurrence of an identifier, for example of a variable or of a method.
\begin{figure}[H]
    \centering
    \includegraphics{analysis/namesegmentbsp.png}
    \caption{Properties and Fields of a NameSegment Expression}
    \label{fig:namesegment}
\end{figure}
While \code{ResolvedExpression} looks like an interesting property, it just points to itself in a regular case, not to the declaration.
Thus, if a name segment is encountered, for example as the right hand side of an assignment, the AST node provided by Dafny does not contain any information about its origin.\\

A better example may be on a higher level.
Regarding the AST-element \code{method},
it contains properties and methods for its body, but not exactly which name segments are declared inside that body.
Also, there is no way to know where that method is used.

\begin{figure}[H]
    \centering
    \includegraphics{analysis/methodbsp.png}
    \caption{Properties and Fields of a Method}
    \label{fig:method}
\end{figure}

To be in control, which information is stored, it was decided to implement an own symbol table / AST combination.
This component will be called \textit{symbol table} throughout this thesis, although it will have a double linked tree structure, as we will see later.


%%%%

\subsection{Visitor}
To generate a symbol table, it is common to use the visitor programming language pattern by Gamma et al \cite{gof}.
The pattern is used to navigate through, mostly tree-based, data structures and execute operations while doing so.
The goal of the pattern is to separate the navigation through the data structure, and the operations that take place when visiting.\\

Consider any tree based data structure.
Every node in the tree is supposed to offer an \code{Accept(Visitor v)} method.
This method will accept the visitor, this is, it will execute the visitor's operation on the node itself.
Further, it will also call the \code{accept}-methods of its child nodes.
Thus, a typical implementation of an acceptor would look like this:

\begin{lstlisting}[language=csharp, caption={Example for Accept}, captionpos=b, label={lst:accept}]
public void Accept(Visitor v) {
    v.Visit(this);
    foreach (Node child in this.Children) {
        child.Accept(v);
    }
}
\end{lstlisting}

Note that the navigational aspect - the foreach loop - is inside the accept method, but nothing is told about the visit operation.
The visitor can do whatever it wants with the node, for example print it to the console.
To work with every node that may occur, the visitor must overload the \code{Visit(Node n)} method for each possible subclass of \code{Node}.
Within a tree, these are usually just nodes and leaves.
For a symbol table, possible node types are any kinds of expressions and statements.

A visitor implementation could look like shown below.

\begin{lstlisting}[language=csharp, caption={Example for Visitor}, captionpos=b, label={lst:visitor}]
public class Printer : Visitor {
    public override void Visit(Node n) {
        Console.WriteLine("Node: " + n.ToString());
    }
    public override void Visit(Leaf n) {
        Console.WriteLine("Leaf: " + n.ToString());
    }
}
\end{lstlisting}

\subsection{Dafny Expression and Statement Types}
\label{section:analysis_dafnyASTStuff}
Dafny is a very versatile language.
While it offers common object oriented language features, it also contains formal language features, comparable to languages like Haskell \cite{haskell}.
This results in a humungous variety of AST-nodes.
The most important ones are discussed in this section.\\

Dafny works with three major base classes in its AST.
These are
\begin{itemize}
    \item Expression
    \item Statement
    \item Declaration
\end{itemize}
Aside these, some AST-nodes are separated, such as \code{AssignmentRHS}, which is the right hand side of an assignment.
\code{LocalVariable} is another example for an isolated class, that does not extend any base class.
Why this isolation of certain AST-nodes was made by Dafny could not be evaluated.
Both items are technically expressions and could thus be subclasses of \code{Expression}.

\subsubsection{Expressions}
In this chapter, the most important expression types are explained.
These are also the expressions that were implemented with a dedicated \code{Accept} and \code{Visit}-method.
\begin{itemize}

    \item NameSegment: Any name of a variable or method.
    \item BinaryExpression: An expression with two operands, for example 'plus', or 'less than'.
    \item NegationExpression: The negation of a variable or literal, for example \code{-b}.
    \item UnaryOpExpression: A unary expression, mostly connected to the "not"-Operator, for example \code{!someBoolean}.
    \item ITEExpr: If-then-else expression, such as \code{if a < 0 then -a else a}
    \item ParensExpression: Any expression surrounded by brackets.
    \item AutoGhostIdentifierExpr: A variable declaration can also contain an initial assignment as well. If so, the left hand side of the declaration is a ghost-identifer.
    \item LiteralExpression: Literals like numbers or strings.
    \item ApplySuffix: The brackets after a method. This expression just refers to the brackets, the actual arguments are stored within the method statement.
    \item MaybeFreeExpr: Occurs at ensure-clauses and contains a single subexpression.
    \item FrameExpr: Occurs at the modifies-clause and contains a list of subexpressions.
    \item Formals: Arguments and return values of a method.
\end{itemize}
The reader notes himself, that many expressions contain other subexpressions.

\subsubsection{Statements}
\begin{itemize}
    \item BlockStmt: Anything surrounded by curly brackets.
    \item IfStmt: A classic if-statement. It contains an expression for the condition, a block statement for the then-block, and another, optional if-statement for the else-block.
    \item WhileStmt: A while-loop. It also contains a block statment for its body and an expression for the condition. Aside these, it also contains expressions for the loop invariants, variants and decrease-clauses.
    \item Method: A method contains a block statement for its body. The arguments and return values are stored as formals.
    \item Function: Analog to method.
\end{itemize}

\subsubsection{Declarations}
The following declarations were analyzed:
\begin{itemize}
    \item ModuleDecl: The declaration of a module.
    \item ClassDecl: A class declaration.
    \item Field: A variable member of a class.
    \item Method: A method member of a class.
    \item Function: A function member of a class.
\end{itemize}

%%do wiiter


\subsection{Dafny AST Implementation}
During analysis of the Dafny AST, it was noticed that the file \code{DafnyAst.cs} is huge.
It contains eleven thousand lines of code and a large number of classes.
This is so extensive that even Visual Studio struggles with it and crashed occasionally on performing autocompletions.\\

Since this file and its contained classes will have to be extended by \code{Accept}-methods
to implement a the visitor pattern, it was considered to refactor the whole file.\\

Splitting the file into individual class files and dividing it into a separate packages would provide a mutch better maintainability.
The following advantages are particularly evident:
\begin{itemize}
    \item Clearer separation
    \item Better overview
    \item Better IDE performance
    \item As a result, less error-prone coding
\end{itemize}

However, there would also be individual disadvantages:
\begin{itemize}
    \item Time-consuming
    \item Inconsistency: Any other Dafny files would still be rather large. Refactoring should then be extended
    \item The maintainers of Dafny may not want a refactored style at all, because they are used to the current situation
    \item By swapping out all lines of code, the top level of the git history would be disturbed for git blame
\end{itemize}

It was decided not to carry out a refactoring.
It would be very time consuming and we would have to extend the refactoring to the whole Dafny project.
Since the time frame of the bachelor thesis is limited, ressources should rather be used at the own code segments and the core concept of the bachelor thesis, such as the implementation of the symbol table.
However, refactoring the code of Dafny itself is one of the possible outlooks of this project.



%%%%%%%%%%%%%%%%%%%%%%%



\subsection{Continuous Integration (CI)}
Continuous integration is a very important part for code quality and colaboration.
Unfortunately, setting up the CI process in the preceding project\cite{sa} took almost until the end of the project stage.

According to our project plan, we wanted to resolve all CI-issues at the beginning of the bachelor thesis, so that we can then profit by a supportive workflow.

This chapter describes the initial situation, the desired objectives and the targets achieved.

\subsubsection{Initial Situation}
On the client side, code was analyzed with SonarQube durring the CI process.
If the code contained TypeScript errors, the build failed \cite{sa}.
The end-to-end tests, provided by the preceding bachelor thesis\cite{ba} could not be integrated until the end of the project, due to their heavy dependencies.\\

On the server side, the project was automatically built by the CI server.
Our own unit tests, as well as tests provided by Dafny could as well be automatically exectued.
Integration testing and code analysis by SonarQube remained pending \cite{sa}.

\subsubsection{Targeted Solution - Achieved Solution}
According to our research, a major problem was that the scanner for SonarQube can only analyze one language at a time \cite{sonar-supports-only-one-language}.
This means, that the TypeScript code in the client and the \Csharp code in the server cannot be analyzed simultaneously.
Furthermore, in the preexisting Dafny project, there are also single Java files.
This led to further conflicts in the Sonar analysis \cite{sa}.\\

As a simple solution, we decided to separate the client (VSCode plugin) and server (Dafny Language Server) into two separate git repositories.
This not only simplifies the CI process but also ensures a generally better and clearer separation \\

As a result, the client could still be easily analyzed with the previous Sonar scanner.
Regarding the server, a special Sonar scanner for MSBuild had to be installed, which publishes the analysis in a dedicated SonarCloud project \cite{dev}.
The available statistics are very helpful for code reviews.\\

The only downside is that the code coverage is not analyzed.
Searching for an alternative, \textit{OpenCover} was found as a very common tool for code coverage analysis in \Csharp.
Unfortunately, it only runs under Windows  \cite{opencover}.
The CI server bases on Linux, though.
During our research we came across monocov \cite{monocov}.
This tool would run under Linux and analyze .NET Framework projects.
Unfortunately this project was archived and has not been supported for almost 10 years \cite{monocov}.

Since we would not gain much value with sonar code coverage, we decided not to pursue this approach any further.
The coverage information is provided by the locally installed IDEs anyway.\\

The end-to-end tests base on a lot of dependencies, such as a headless instance of Visual Studio Code.
In consultation with our supervisor, we have removed these tests from the client project and replaced them with own specially written integration tests on the server side.

\subsubsection{Docker}
The CI server bases on a Docker distribution.
Docker's lightweight virtualization is ideally suited to run the CI environment.

For an easier testability of the CI, we also installed Docker locally.
This allowed us to resolve CI issues locally and platform-independently (through the Docker Client) in case of problems.
See the developer documentation for more details \cite{dev}.\\

Docker also realizes the priciple "Cattle, not pets" with docker.  \intnote{hier noch irgend eine cite adden wo das prinzip definiert wird... hab nur grad stackoverflow gefunden, was zitierfähiges wäre nett. sonst wirkt es fast etwas kindisch/verpsielt fürü eine BA.}
Instead of having certain package dependencies that need to be updated continuously (pet), a "build, throw away, rebuild" procedure (cattle) is used.
This way, the dependent packages will always be up to date and security patches and the like are automatically deployed.\\

Excluded from this principle are Node, Z3, Go, Boogie and Sonar.
All of these have to be installed in specific release versions within the CI server.
This is, since Dafny relies on specific deployments of these products. See the developer documentation for more details \cite{dev}. \\
\intnote{wtf ist go, und node und sonar ist doch egal werlche version oder?}

\subsubsection{2do - Kapitelaufteilung komisch}
Ich hab hier jetzt in der Analyse auch schon die Lösung vorabgegriffen. Sollen wir das splitten? Bricht das nicht den Lesefluss? Evt besprechen.
ja es is iwie komisch. auch unten habenw ir ja noch testing und blabla... kann man evtl so ein CI Kapitel vlt sogar machen? grml.

todo


\subsection{notizen von marcel}

$\rightarrow$ Gedanken zum Updaten sind wichtig. Evt ned alles implementieren aber dokumentieren.... Effizienz. Ned alles neu Builden
wenn in einem File nur ein Zeichen geändert wird auf einer Linie etc. $\rightarrow$ Ausblick.

Und Testing in einem grossen Dafny Project wär evt auch noch ganz nice... ein paar Performance-Tests und so?
Und die dann mit dem Plugin aus der Studienarbeit vergleichen? Und dem alten-alten Plugin? Käme bestimmt jut an.


\subsection{notizen von tom}
gleich nachm schreiben, was mir onch so durch den kopf geht:
\begin{itemize}
    \item Visitor Pattern braucht auch olaf und guido nicht jeden tag. Kommen die draus? Wäre nicht ein schema-bildchen noch gut, aka 'kuck hier links, der accept sagt wo ich durch muss, udn kuck hier rechts, der visitor sagt was getan wird. oder irgend sowas, ka.
    \item expression list und co total random... halt brutal unvollständig etc pp. erklären, warum das unvollständig ist.
    \item SymbolTable, AST, connected, blabla... ist das gut genug? Corbat hat sehr viel Ahnung davon und mein Halbwissen ist da ein bisschen gefährlich, das gibt dann ja total schelchten eindruck.
    \item Lanague Feautres: am anfang noch spezifisch schreiben, dass wir jetzt nur auf den shit eingehen, der für symboltable relevant ist, aka wo könnten doppelte namen vorkommen.
    \item Ist der flow eig klar? wir müssen ne symbolt able machen, $\Rightarrow$ was hat n dafny da überhaupt so, $\Rightarrow$ wie machen wir es, $\Rightarrow$ visitor is gut für sowas $\Rightarrow$ muss dies und das visitien.
\end{itemize}
