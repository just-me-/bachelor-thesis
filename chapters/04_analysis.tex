\section{Analysis}
\label{section:analysis}
Since this thesis is a sequel of the preceding semester thesis, work could be directly continued.
Many topics were already analyzed in the prequel.
To provide the reader with a comprehensive knowledge base about Dafny and the language server protocol (LSP), some sections out of the semester thesis will be repeated in the following subsections.
The studies of the Dafny-specific compilation process was new to the bachelor thesis.
It was especially necessary to gain an overview of the existing abstract syntax tree nodes to build the new symbol table.

 \intnote{Prepare reader for content in the chapter. Give an overview of the sections and state which are copied.}

\subsection{Language Server Protocol}
\label{section:analysis:lsp}
The language server protocol (LSP) is a JSON-RPC based protocol to communicate between an IDE and a language server \cite{lspWiki}.
In 2016, Microsoft started collaborating with Red Hat and Codenvy to standardize the protocol’s specification \cite{lspWiki}.
The goal of the LSP is to untie the dependency of an IDE with its programming language.
That means, that once a language server is available, the user is free in the choice of the IDE, as long as it offers a client instance that is able to communicate with the server.
The user can then use a variety of features, as long as the language server is capable to handle them. \glsadd{lsp}
Those features can for example be
\begin{itemize}
    \item AutoCompletion
    \item Hover Information
    \item Rename
    \item GoToDefinition
\end{itemize}
and much more. A full list can be found within the LSP specification \cite{lspspec}.
Custom requests, for example for features like Compile or CounterExample, can also be added to the LSP \cite{lspWiki}.
The major advantage of this concept is that the plugin can be kept very simple.
The relevant information is delivered by the language server, which is IDE-independent.
Figure \ref{fig:lspcommunication} from the VSCode extension guide illustrates these benefits .

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{analysis/lspcommunication.png}
    \caption{Communication Benefit of LSP, Image from \textit{visualstudio.com} \cite{lspextensionguide}}
    \label{fig:lspcommunication}
\end{figure}

\subsubsection{Message Types}
The LSP supports three types of messages.
\begin{itemize}
    \item Notification: One-way message, for example for a window notification.
    \item Request: A message that expects a response.
    \item Response: The response to a request.
\end{itemize}
Each message type can be sent from both sides. From client to server and from server to client.

\subsubsection{Language Features}
Aside regular communication, such as text document synchronization,
the language server protocol specifies a large number of language features \cite{lspspec}.
These are shown in figure \ref{fig:lsplanguagefeatures}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth/2]{04_lsplanguagefeatures.png}
    \caption{List of Language Features Interfaces TODO make list}
    \label{fig:lsplanguagefeatures}
\end{figure}

Certain functions, which are needed for the Dafny plugin, are not offered by the standard.
Fortunately the LSP can be extended with custom requests. This concerns the following features:
\begin{itemize}
    \item Compile: Informs the server about the file to compile and compilation arguments.
          As a result, the server delivers a success or error message.
    \item CounterExample: The client sends a file identificator to the server and receives
           CounterExamples in response.
\end{itemize}

Custom LSP messages are further discussed in section \ref{chapter:customlspmsg}.

\subsubsection{Communication Example}
The basic concept of the LSP is to inform the server about any client action.
For example, when the user is opening a document, the notification \code{textdocument/didOpen} is sent.
The message contains the URI of the opened document, so that the language server can load the source code.
Whenever the user is typing, the notification \code{textDocument/didChange} is sent.
It contains any changes that were made.\\

The language server on the other hand can verify the opened or changed document and test it for errors.
If errors are found, the server is able to send a \code{textDocument/publishDiagnostics} notification back to the client.
The client may now underline the erroneous code range \cite{lspspec}.
Since the protocol is standardized, the client supporting the LSP is natively able to handle the diagnostics notification, without any actions necessary by a developer.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{03_lspmsgexample.png}
    \caption{LSP Example Communication}
    \label{fig:lspmsgexample}
\end{figure}

\subsubsection{Message Example}
The following message in listing \ref{lst:lspjsonmsg} is a \code{textDocument/publishDiagnostics} notification as it appears in figure \ref{fig:lspmsgexample}.
It states that on line 4, from character 12 to 17, there is an assertion violation.
Note the JSON-based message format.\\

\begin{lstlisting}[language=json, caption={LSP Message Example}, captionpos=b, label={lst:lspjsonmsg}]
[12:45:29 DBG] Read response body
{
   "jsonrpc":"2.0",
   "method":"textDocument/publishDiagnostics",
   "params":{
      "uri":"file:///D:/[\ddots]/fail1.dfy",
      "diagnostics":[
         {
            "range":{
               "start":{
                  "line":4,
                  "character":12
               },
               "end":{
                  "line":4,
                  "character":17
               }
            },
            "severity":1,
            "code":0,
            "source":"file:///D:/[\ddots]/fail1.dfy",
            "message":"assertion violation"
         }
      ]
   }
}
\end{lstlisting}

\subsection{OmniSharp}
\label{section:analysis:omnisharp}
To create a language server, a proper LSP implementation is required.
OmniSharp offers support for \CsharpWithSpace \cite{langserverdotorg} in the form of a NuGet package. \glsadd{nuget}
NuGet is the package manager in the Microsoft univers \cite{nuget}.
A language server client that can be used for testing is also offered.

\subsubsection{Basic OmniSharp Usage}
Mr. Martin Bj\"orkstr\"om published a comprehensible tutorial about OmniSharp's language server protocol implementation.
The tutorial provides the user with all the required knowledge to set up a language server in \Csharp.
Besides the setup of the server, it also illustrated how to create message handlers, for example for AutoCompletions or document synchronization.\\

\begin{lstlisting}[language=csharp, caption={LSP Handler Implementation}, captionpos=b, label={lst:lspbasichandler}]
public class AutoCompletion : ICompletionHandler
{
    public Task<CompletionList> Handle(CompletionParams request, CancellationToken cancellationToken)
    {
        throw new NotImplementedException();
    }
}
\end{lstlisting}

Listing \ref{lst:lspbasichandler} illustrates that the user simply has to implement an interface provided by OmniSharp.
Within the \code{request} parameter, all required information is passed to the handler.
For AutoCompletion, this is the file and the cursor position, as well as some context information, how the AutoCompletion event was triggered.
The task of the language server is to figure proper suggestions and return them in the form of a \code{CompletionList} back to the client.\\

Since OmniSharp is open source, we could find all available interfaces and thus all available handlers in their git repository \cite{omnisharpgit}.
Aside the official LSP specification, this collection is very helpful to perceive LSP's possibilities.

\subsubsection{Custom LSP Messages}
\label{chapter:customlspmsg}
The current problem domain does not only require premade LSP messages like AutoCompletions or diagnostics, but also custom requests such as \code{CounterExample}, which is Dafny-specific.
Such a message is not natively supported by the language server protocol.
Since no example or documentation could be found on custom messages, Martin Bj\"orkstr\"om was contacted in the OmniSharp Slack channel \cite{omnisharpslack}.
Mr. Bj\"orkstr\"om and his team were able to quickly provide the solution for this issue.\\

The server can simply register custom handlers by implementing the correct interfaces.
The following three items have to be specified:
\begin{itemize}
    \item Name of the message, e.g. \code{CounterExample}
    \item Parameter type, e.g. \code{CounterExampleParams}
    \item Response type, e.g. \code{CounterExampleResults}
\end{itemize}


The parameter and response types can be custom classes and more flexibility.
The following skeleton code demonstrates how a custom request handler can be implemented:

\begin{lstlisting}[language=csharp, caption={LSP Handler Implementation for CounterExample}, captionpos=b, label={lst:lspcustomhandler}]
public class CounterExampleParams : IRequest<CounterExampleResults> { ... }
public class CounterExampleResults { ... }

[Serial, Method("CounterExample")]
public interface ICounterExampleHandler : IJsonRpcRequestHandler<CounterExampleParams, CounterExampleResults> { }

public class MyHandler : ICounterExampleHandler
{
    public async Task<CounterExampleResults> Handle(CounterExampleParams request, CancellationToken c)
    {
        CounterExampleResults r = await DoSomething(request);
        return r;
    }
}
\end{lstlisting}


\subsection{Visual Studio Code Plugin}
To provide a plugin for Visual Studio Code, a custom extension must be programmed.
To get a rough understanding of how to build such an extension
and how to run and debug an own plugin, a tutorial was already studied during the preceding semester thesis.
In the tutorial "Your First Extension”, basic concepts for own plugins were learned \cite{vscode-first-extension}.
Examples for integrating a Language Server were found on the advanced examples page "Extension Guides" \cite{vscode-extensions}. \\

Creating a simple plugin extension generates the folder structure shown in figure \ref{fig:vs_code_extension_file_structure}.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/vs_code_extension_file_structure}
    \caption{VSCode Extension File Structure}
    \label{fig:vs_code_extension_file_structure}
\end{figure}

The primary components are the two TypeScript files for the extension manifest and the extension source code. \\

Basic plug-in configurations are specified in the manifest.
These include, for example:
\begin{itemize}
    \item The name of the plugin.
    \item The version.
    \item Command registrations.
    \item The specification of which files the plugin should be active on.
\end{itemize}

The plugin launches by calling the method \code{activate} within \code{extension.ts}.

\begin{lstlisting}[language=typescript, caption={extension.ts}, captionpos=b, label={lst:extension-file}]
import * as vscode from 'vscode';

// This method is called when the extension is activated.
export function activate(context: vscode.ExtensionContext) {
  // entry point
}
\end{lstlisting}

The logic contained in the client is supposed to be minimal.
The primary logic is handled by the Dafny language server.
To communicate with the language server, the language server must first be started locally as a process by the plugin. \\

In the prototype, it is assumed that the server is located in a specific directory relative to the client.
Since the Dafny language server is not part of the plugin delivery to the VSCode Market Place,
this is an issue for the plugin release.
An automated download of the newest release of the Dafny language server was missing.
Therefore, a goal of this bachelor thesis was to perform an automated download of the Dafny language server to the local machine of the user.

\subsection{Dafny Language Features}
With regard to the symbol table, Dafny had to be studied more in detail.
For example, shadowing describes the existence of multiple variables with the same name, but different visibility scopes.
Concepts like these are highly relevant for the construction of a symbol table. \\

To be aware of which such concepts are supported - or prohibited - by Dafny, we studied the \textit{Dafny Reference Manual} \cite{dafnyReferenceManual}.
This section discusses the most relevant Dafny language concepts with regard to the symbol table.

\subsubsection{Modules}
Dafny code can be organized by modules.
A module is comparable to a namespace in \CsharpWithSpace or C++.
Modules can also be nested.
To use a class defined in another module, the user has three options.
Imagine a method \code{addOne} defined in a module \code{Helpers} as shown in listing \ref{lst:addOneMethod}.

\begin{lstlisting}[language=dafny, caption={Module Example}, captionpos=b, label={lst:addOneMethod}]
module Helpers {
    function method addOne(n: nat): nat {
        n + 1
    }
}
\end{lstlisting}

\begin{itemize}
    \item The user states the module name explicitly in front of the method he wants to call, \linebreak namely \code{Helpers.addOne(5)}.
    \item The user imports the module, for example with \code{import H = Helpers}.
    Afterwards, he may type \code{H.addOne(5)}.
    \item The user imports the module in opened state: \code{import opened Helpers}.
    Now the user is eligible to skip the namespace identifier and can just write \code{addOne(5)}.
\end{itemize}

Importing a module in opened state may cause naming clashes.
This is allowed, but in this case, the locally defined item has always priority over the imported one.
For example, in listing \ref{lst:moduleShadowing}, the assert statement is violated, since the overwritten \code{addOne} has priority \cite{functionVSMethod}.

\begin{lstlisting}[language = dafny, caption={Naming Clash}, captionpos=b, label={lst:moduleShadowing}]
module Helpers {
    function method addOne(n: nat): nat {
        n + 1
    }
}
function addOne(n: nat): nat {
    n + 2
}

import opened Helpers
method m3() {
    assert addOne(5) == 6; //violated
}
\end{lstlisting}

To import a module defined in another file, the user has to import the file using the expression \code{include "myFile.dfy"}.
This includes all content of the included file into the current file.

\subsubsection{Functions and Methods}
Dafny has two types of methods, or functions respectively.
For a programmer used to \CsharpWithSpace or C++, this concept may be confusing at first, but is very simple:
\begin{itemize}
\item A \textit{method} is what a programmer from \CsharpWithSpace or C++ may be used to.
A sequence of code, accepting some parameters at the beginning and returning some values at the end.
It can be a class member or be in global space.
\item A \textit{function} is more like a mathematical function.
It takes an input and returns a single value.
The function must consist of only one expression.
For example, consider listing \ref{lst:function}.
Furthermore, functions are not compiled into the final executable and may only be used in specification context.
That is, in contracts or assert statements to proof logical correctness prior to compilation \cite{functionVSMethod}.
\item A \textit{function method} is just both at once.
It contains a single expression with a single return, but is also compiled and thus also available in regular context \cite{functionVSMethod}.
\end{itemize}

 \intnote{Das check ich ned ganz. beispiee für beide fälle damit man den unterschied sehen kann. erstes ist mit code referenziert aber da steht function method min. funktion nach art benennen. myMinFunction. myMinFunctionMethod. dann ists klar.}

\begin{lstlisting}[language=dafny, caption={Function Method Example}, captionpos=b, label={lst:function}]
function method min(a:int, b:int) : int
{
    if a < b then a else b
}
\end{lstlisting}

Further concepts include:
\begin{itemize}
\item A \textit{predicate} is just a function returning a bool value.
\item An \textit{inductive} predicate is a predicate calling itself.
\item A \textit{lemma} is a mathematical fact.
It can be called whenever Dafny cannot prove something on its own.
By calling the lemma, the user tells Dafny a fact it can use for its proof \cite{dafnyReferenceManual}.
An example can be found in listing \ref{lst:lemma_example}.
\end{itemize}

\begin{lstlisting}[language=dafny, caption={Lemma}, captionpos=b, label={lst:lemma_example}]
lemma ProvingMultiplication(c: int, m: int)
    ensures c*m == m + (c-1)*m
{}
\end{lstlisting}

\subsubsection{Hiding}
Hiding is when a derived class redefines a member variable of the base class.
Dafny supports inheritance with traits.
A trait is basically an abstract class.
While the trait can define a class variable, any class deriving from it is not allowed to redefine that class variable.
Consider the following example.
The commented code line would cause an error \cite{dafnyReferenceManual}.

\begin{lstlisting}[language=dafny, caption={Hiding}, captionpos=b, label={lst:hiding}]
trait Base {
    var a: int
}

class Sub extends Base {
    constructor() {}
    //var a: int          //Error
}
\end{lstlisting}

This means that this issue does not have to be considered any further with regard to the symbol table.

\subsubsection{Overloading}
Overloading describes the definition of a method with an existing name, but a different signature.
This is, with a different parameter list.
Dafny prohibits this language concept to be able to uniquely identify each method by solely its name \cite{dafnyReferenceManual}.
This means, that within each module, each method name is unique.

\subsubsection{Shadowing}
Shadowing means that a class method redefines a variable that was already previously defined as a class member.
This means that two variables with the same name exist.
The local variable can be accessed via its name, but to access the class member, the programmer needs to write \code{this} in front of the variable name.\\

One can even go further and redefine a local variable in a nested block scope.
Consider the following code snippet in listing \ref{lst:shadowing}.
It defines a class with a member variable \code{a}.
It is initialized with value $2$ in the class constructor.
In method \code{m}, the variable \code{a} is printed.
This will output $2$, since the class variable is the only one we are aware of.
Next, a variable with the same name is redefined.
The class variable is now shadowed by the local variable.
Printing \code{a} will now print the local variable.
To access the class variable, the this-locator is required.

\begin{lstlisting}[language = dafny, caption={Complex Shadowing Example}, captionpos=b, label={lst:shadowing}]
class A {
    constructor () { a := 2; }
    var a: int
    method m()
    modifies this
    {
        print a;           // 2
        var a: string := "hello";
        print a;           // hello
        print this.a;      // 2
        {
            print a;       // hello
            var a: bool := true;
            print a;       // true
            print this.a;  // 2
        }
    }
}
\end{lstlisting}

In line 11, a nested scope is opened.
Printing \code{a} at first will still yield the local variable.
However, in the nested scope, we can redefine \code{a} again, shadowing the own local variable.
Further calls of \code{a} will then return the boolean value.
\code{this.a} will still yield 2, even inside the nested scope.\\

This behaviour can be summarized with the following three rules:
\begin{itemize}
    \item If the variable was defined locally before its usage, the local definition is significant.
    \item If the variable was not defined locally before its usage, the parent scope is significant.
    \item If a class member is called via the \code{this} identifier, the class member is significant.
\end{itemize}

During analysis of this problem, the in listing \ref{lst:findsymbol} recursive algorithm was created
to solve the problem of finding a symbols relevant declaration.

\begin{lstlisting}[language=csharp, caption={Finding Symbol Definition}, captionpos=b, label={lst:findsymbol}]
private Symbol FindDeclaration(Symbol target, Symbol scope)
{
    foreach (Symbol s in scope.AllSymbols)
    {
        if (s.Name == target.Name && s.IsDeclaration)
        {
            return s;
        }
    }
    if (scope.Parent != null)
    {
        return FindDeclaration(target, scope.Parent);
    }
}
\end{lstlisting}
The code had to be adjusted later on, to also respect inherited symbols and to also check inside the default scope.
If all declarations are known, the algorithm does already work for symbols defined after the first usage.

\subsection{Existing Dafny Visitor Component vs Required Symbol Table}
Whenever source code is compiled into an executable assembly, the first step is to \textit{parse} the code.
The parser of a compiler works with two major concepts.
One of them is the abstract syntax tree (AST), the other is the symbol table. \glsadd{ast}
The AST is a tree, that contains information about the scope of symbols.
Consider the following code snippet.

\begin{lstlisting}[language=dafny, caption={AST Demo Snippet}, captionpos=b, label={lst:astsnipped}]
while(i < 5) {
    i := i + 1;
    print i;
}
\end{lstlisting}

The tree segment for this snippet would contain of the while-Statement as the root node.
It then has two branches, one for the condition, and one for the body of the while statement.
The body itself consists of a list of statements.
In the above example, there are two statements.
The first one is an assignment.
The assignment has again a left and a right side.
The right hand side is a binary expression, with the +-operator in between two operands.
The left operand is a name segment expression, and on the right hand side is a literal expression.
The second statement inside the body is a simple print statement with only one item to print, the name segment expression \code{i}.
While these are just three lines of code, the AST is already quite large compared to the code.\\

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/DemoASTWithWhileLoop.png}
    \caption{AST Example}
    \label{fig:ast_for_example}
\end{figure}

The tree structure can be well seen in figure \ref{fig:ast_for_example}.
Usually, the AST does not contain information about the type of symbols.
This is where the symbol table comes into play.
The symbol table contains that information and is connected to the AST, for example by the use of a dictionary, linking an AST-node to a symbol table entry.
With the help of the symbol table, it can be figured that the name segment \code{i} is of type int.
The two concepts are strongly coupled.

\subsubsection{Requirements for the Symbol Table}
To be able to implement the required feature set for this project, the following questions must be answered by the symbol table or the AST, respectively.

\begin{itemize}
    \item Cursor position
    \begin{itemize}
        \item Which name segment (if any) is at the cursor's position?
        To have a symbol as an entry point for the GoToDefinition feature.
    \end{itemize}

    \item GoToDefinition
        \begin{itemize}
            \item Where is the symbol declared?
            To go from the received entry symbol to the declaration symbol.
        \end{itemize}

    \item CodeLens
        \begin{itemize}
            \item How often, and where, is a declaration used?
            To display the references to the plugin user.
        \end{itemize}

    \item Rename
        \begin{itemize}
            \item What are all occurrences of a symbol?
            To rename all symbols correctly.
        \end{itemize}

    \item AutoCompletion
        \begin{itemize}
            \item Within which scope was the event triggered?
            To suggest only symbols in the reachable scope.
            \item Which declarations are available inside a certain scope?
            To suggest all symbols over several files, which are accessible.
            \item What is the context; what was just typed before (e.g. a dot or the keyword \code{new})
            To provide the user with more specific suggestions.
        \end{itemize}
\end{itemize}

\subsubsection{Dafny Symbols}
In an optimal case, Dafny's own implementation of its symbol table and AST would already contain all of this information.
Unfortunately, this was not the case.
Dafny uses the Coco/R library for its compilation.
This library can generate a source code parser, is thus just generating the AST \cite{coco}.
As one can note regarding figure \ref{fig:ast_for_example}, the AST is not really providing the information required in the list above.
For example, the question where \code{i} is declared is not answered.
Also, some information is not even relevant for the language server.
Within a binary statement, the operand is not of interest for example.\\

Figure \ref{fig:namesegment} shows all available properties and fields of a name segment.
A name segment is just any occurrence of an identifier, for example of a variable or of a method.
\begin{figure}[H]
    \centering
    \includegraphics{analysis/namesegmentbsp.png}
    \caption{Properties and Fields of a NameSegment Expression}
    \label{fig:namesegment}
\end{figure}
While \code{ResolvedExpression} looks like an interesting property, it just points to itself in a regular case, not to the declaration.
Thus, if a name segment is encountered, for example as the right hand side of an assignment, the AST node provided by Dafny does not contain any information about its origin.\\

A better example may be on a higher level.
Regarding the AST-element \code{method} in figure \ref{fig:method},
it contains properties and methods for its body, but not exactly which name segments are declared inside that body.
Also, there is no way to know where that method is used.

\begin{figure}[H]
    \centering
    \includegraphics{analysis/methodbsp.png}
    \caption{Properties and Fields of a Method}
    \label{fig:method}
\end{figure}

To be in control which information is stored, it was decided to implement an own symbol table / AST combination.
This component will be called \textit{symbol table} throughout this thesis and the project source code, although it will have a double linked tree structure, as we will see later.
\textit{Symbol Tree} would consequently be a more accurate name.

%%%%


\subsection{Dafny Expression and Statement Types}
\label{section:analysis_dafnyASTStuff}
Dafny is a very versatile language.
While it offers common object oriented language features, it also contains formal language features, comparable to languages like Haskell \cite{haskell}.
This results in a humungous variety of AST-nodes.
The most important ones are discussed in this section.\\

Dafny works with three major base classes in its AST.
These are:
\begin{itemize}
    \item Expression
    \item Statement
    \item Declaration
\end{itemize}
Aside these, some AST-nodes are isolated, such as \code{AssignmentRHS}, which is the right hand side of an assignment.
\code{LocalVariable} is another example for a separated class, that does not extend any base class one would expect.
Why this isolation of certain AST-nodes was made by Dafny could not be evaluated.
Both items are technically expressions and could thus be subclasses of \code{Expression}.
Figures \ref{fig:dafny_expr}, \ref{fig:dafny_stmt}, \ref{fig:dafny_decl} and \ref{fig:dafny_vars} follow the structure given by Dafny and present the AST-elements that were analyzed.
These are also the nodes a dedicated \code{Accept} and \code{Visit}-method was implemented for.\\

Since most of them are self-explanatory, only chosen nodes are explained.

\pagebreak

\textbf{Expressions}\\
\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{expressiontypes/expr.png}
    \caption{Dafny Expression Types}
    \label{fig:dafny_expr}
\end{figure}

The reader notes himself in figure \ref{fig:dafny_expr}, that many expressions contain other subexpressions.
For example, a \code{IdentifierExpr} is nothing more than containing a \code{NameSegment}.\\

An interesting node is \code{AutoGhostIdentifierExpr}.
It occurs, whenever a variable declaration also contains its initialization, for example \code{var a := 2}.
Internally, this declaration is represented as \code{var a : int; a := 2}.
As we see now, the second \code{a} is a pseudo-veriable, or how Dafny calls it, a \textit{AutoGhostIdentifier}.\\

\code{ComprehensionExpression} contains a variety of sublcasses, such as the \code{ForallExpr}, \code{SetComprehension} and \code{LambdaExpr}.
All of these contain bound variables (the parameters of the lambda for example) and an expression afterwards.\\
\code{|a|} denots the size of the set \code{a}.\\

\pagebreak
\textbf{Statements}\\
\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{expressiontypes/stmt.png}
    \caption{Dafny Statement Types}
    \label{fig:dafny_stmt}
\end{figure}

An interesting statement in figure \ref{fig:dafny_stmt} is \code{AssignSuchThat}.
Here, Dafny chooses what to assign, such that the condition holds.
The programmer does not know exactly, which number will be assigned.\\

\textbf{Declarations}\\
\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{expressiontypes/decls.png}
    \caption{Dafny Declaration Types}
    \label{fig:dafny_decl}
\end{figure}

\pagebreak
\textbf{Other}
\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{expressiontypes/vars.png}
    \caption{Dafny Various Types}
    \label{fig:dafny_vars}
\end{figure}

These form the most important AST-nodes.
Dafny provides many more of them.
Due to the limited time frame, not all of them could be analyzed.
A benefit of the visitor pattern is, that it can just be implemented once for the base interface \code{IAstNode} with an empty action.
This way, the visitor will just do nothing for nodes that are not supported.

\subsection{Refactoring of the Given Dafny AST Implementation}
During analysis of the Dafny AST, it was noticed that the file \code{DafnyAst.cs} is humungous.
It contains eleven thousand lines of code and a large number of classes.
This is so extensive that even Visual Studio struggles with it and stopped working occasionally on performing refactorings.\\

Since this file and its contained classes will have to be extended by \code{Accept}-methods
to implement the visitor pattern, it was considered to refactor the whole file.\\

Splitting the file into individual class files and dividing it into a separate package would provide much better maintainability.
The following advantages are particularly evident:
\begin{itemize}
    \item Clearer separation.
    \item Better overview.
    \item Better IDE performance.
    \item As a result, less error-prone coding.
\end{itemize}

However, there would also be individual disadvantages:
\begin{itemize}
    \item Inconsistency: Other Dafny files would still be rather large. Refactoring should then be extended.
    \item It is not a planned enlargement of our thesis to refactor Dafny code.
    \item Time-consuming.
    \item Dafny may not want a refactoring at all, because they are used to the current situation.
    \item By swapping out all lines of code, the top level of the git history would be disturbed for git blame.
\end{itemize}

It was decided not to carry out a refactoring.
It would be very time consuming and we would have to extend the refactoring to the whole Dafny project.
Since the time frame of the bachelor thesis is limited, resources should rather be used at the own code segments and the core goals of the bachelor thesis, such as the implementation of the symbol table.
However, refactoring the code of Dafny itself is one of the possible extension points for this project.

\subsection{Prototype Functionality and Flaws to Improve}
\label{section:analysis:features}
In the prototype, some features were already implemented and possible extension points were mentioned.
This chapter describes the state of the prototype as it was at the beginning of this bachelor thesis, as well as the necessary improvements.
It also describes how we intend to implement these improvements.

\subsubsection{Syntax Highlighting}
The syntax highlighting is realized through a given Dafny grammar file.
Figure \ref{fig:analysis_syntax_highlighting} shows how syntax highlighting looks inside Visual Studio Code. \\

As you can see, keywords like method, returns, requires and ensures are marked in purple.
Types like int are printed in blue and comments become green.
Symbols, such as classes and methods, are displayed in a brownish color.
Just these simple rules increase the readability significantly.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth/2]{analysis/syntax_highlighting}
    \caption{Syntax Highlighting}
    \label{fig:analysis_syntax_highlighting}
\end{figure}

In the current public plugin an update was made to the grammar file \cite{syntax_update}.
Among other things, new keywords are now recognized and visually marked, such as "expect".
This update will be applied to the Dafny grammar file for our plugin version as well.

\subsubsection{Verification}
The verification feature underlines logical errors in the user's code.
An example is shown in figure \ref{fig:analysis_verification}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{analysis/verification}
    \caption{Postcondition Violation}
    \label{fig:analysis_verification}
\end{figure}

The logical verification is permanently active.
The user just has to type Dafny code and it will be verified.
The current version only supports logical errors, not syntax errors.\\

Whenever an assertion or postcondition violation appears, the code block is underlined in red.
The actual postcondition is underlined in yellow.
The user can hover over the error to get additional information about the problem. \\

In our thesis we want to extract the syntax errors from the Dafny diagnostic report and show them to the user as well.
Dafny works with so called \code{ErrorReporters}, that should provide the necessary information.\\

In addition, it is noticeable that only the curly opening parenthesis is underlined in case of errors concerning methods.
This can easily be overlooked by the user.
For a more distinctive marking, we would now like to underline the complete method block from the opening to the closing parentheses.
With the previous version, this implementation would have been possible only by extensive string parsing of the code - and that with every change to the Dafny code.
With the planned renewal of the symbol table, we automatically have access to the information where the corresponding closing parenthesis of a code block is.

\subsubsection{Compile}
The user has two options to initiate compilation: He can just compile the software or he can additionally run it on a console inside VSCode.
The commands are available as hotkeys, in the context menu or via the VSCode command bar.
The client will save the document, send its URI, and the server will report back if compilation was successful.
If any errors are present in the code, they are reported as a window notification as shown in figure \ref{fig:analysis_compile}.
This includes syntax errors. If the compiled program can be run, a PowerShell instance is started directly inside Visual Studio Code.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/compile}
    \caption{User Notification on Compile Errors}
    \label{fig:analysis_compile}
\end{figure}

Dafny allows to specify own arguments for compilation, which our plugin should support, too.
On the one hand, extended configuration settings should allow the user to set default values in the plugin, on the other hand the popup box integrated in VSCode can be used for individual argument input for each compile \cite{vscodeAPI}.

\subsubsection{CounterExample}
To show a CounterExample, the user has again the choice between a hotkey, the context menu or using the command bar.
The CounterExample is then shown as a VSCode design element.
If the user is no longer interested in the CounterExample, there is another command to hide it.
The suppression of the counter model is completely handled inside the client. \\

The example in figure \ref{fig:analysis_counter_example} demonstrates a CounterExample.
The precondition is commented. Without this requirement, the postcondition can be violated with \code{y = 0}.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/counter_example}
    \caption{Demonstration of CounterExamples}
    \label{fig:analysis_counter_example}
\end{figure}

In the current version the CounterExample is automatically hidden when the code is edited.
If the user switches to another tab in VSCode, the CounterExample is also deactivated. \\

New client logic has to be used to store for which files the CounterExample is active.
The CounterExample can be displayed to the user again, as soon as he switches back to the original Dafny file with the new logic.
Furthermore, an automatic update of the CounterExample should take place whenever the user edits the code.\\

The representation of the CounterExample shall also be improved.
A clear and concise display and increased user friendliness is targeted.\\

\subsubsection{AutoCompletion for Identifiers}
Whenever a valid interim result of a Dafny file is sent to the server, a naive file symbol table is created and buffered.
As an example, if one would have a Dafny code snippet like below, the best and only match would be method \code{m}.
This is exactly what is suggested for the user as you can see in figure \ref{fig:analysis_completion_1}.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/analysis_completion_1}
    \caption{AutoCompletion for Instance of Class C}
    \label{fig:analysis_completion_1}
\end{figure}

In addition, AutoCompletion is also able to provide general completion suggestions if one is not typing a word.
In this case, just all available symbols are proposed.
This is illustrated below in figure \ref{fig:analysis_completion_1}.
Please also note that every symbol type (i.e. methods, classes and variables) have their own icons.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/analysis_completion_2}
    \caption{General Suggestions with Symbol Types}
    \label{fig:analysis_completion_2}
\end{figure}

Unfortunately, both implemented versions are neither very reliable nor very performant.
AutoCompletion was implemented via string matching.
That means, if the AutoCompletion is called after a dot, the word before the dot is extracted from the source code.
Afterwards the complete symbol table is iterated through and as soon as a symbol with the matching name is found,
it is assumed that this symbol is the originally declared symbol.
If there are multiple symbols with the same name, or if the declaration takes place after the first usage,
the AutoCompletion would no longer work properly. \\

For general suggestions, simply all symbols are suggested.
This includes symbols not visible in the current scope. \\

AutoCompletion has to be rebuilt so that it functions reliably and correct.
This is only possible by the implementation of a proper symbol table.\\

In addition, it would be very useful for users if the autocompletion is triggered after a \code{new}
keyword and only available classes are automatically listed.
This can be achieved by type filtering the symbols of the symbol table.

\subsubsection{GoToDefinition}
With the "GoToDefinition" feature, a user can use the context menu or hit F12 to go to the definition of a symbol.
In figure \ref{fig:analysis_goto_1}, an example is shown.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{analysis/analysis_goto_1}
    \caption{GoToDefinition via Context Menu}
    \label{fig:analysis_goto_1}
\end{figure}

Please note that in the current version, the cursor has to be on the left side of the symbol's keyword.
Once pressed, the cursor jumps instantly to the definition of the desired symbol as it is shown in the following figure \ref{fig:analysis_goto_2}.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{analysis/analysis_goto_2}
    \caption{Cursor Position After GoToDefinition}
    \label{fig:analysis_goto_2}
\end{figure}

GoToDefinition uses a similar logic to AutoCompletion and is therefore just as unreliable.
The name of the currently selected word is read from the cursor position.
Afterwards the whole symbol table is iterated through - the first symbol with the same name is assumed to be the declaration.
Then the position of this symbol is jumped to. \\

Similar to AutoCompletion, the cursor position can reliably identify the currently selected symbol and the new symbol table can determine the declaration symbol.

\subsubsection{CodeLens}
Once a user opens a Dafny file that includes classes, methods or functions, a greyish line shows the reference count to that symbol.
As an example, the class \code{C} has been instantiated twice and the method \code{m} was used once in the following code snippet in figure \ref{fig:analysis_codelens}.

Unfortunately, clicking the grey references is not yet supported.
This should open a popup box in which the corresponding uses are shown.

\begin{figure}[H]
    \centering
    \includegraphics[width=9cm]{analysis/analysis_codelens}
    \caption{CodeLens Example}
    \label{fig:analysis_codelens}
\end{figure}

The current implementation of CodeLens does not have an optimal runtime.
For each symbol, the whole symbol table is iterated again to compare whether one symbol is a use of the other symbol.
This results in a quadratic runtime. \\

With the new symbol table, each symbol knows how often and where it has been used.
Therefore, we only have to iterate through the symbol table once.
Furthermore, the iteration can be limited exclusively to declarations.

%%%%%%CI%&%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Continuous Integration (CI) of the Prototype}
\label{section:analysis:CI}
Continuous integration is a very important part for code quality and collaboration
as you will read in chapter \ref{section:project_management} \textendash{} \nameref{section:project_management}.
Unfortunately, setting up the CI process in the prototype took almost until the end of the project
and was not very successful. \glsadd{ci}

This section describes the initial situation and the desired objectives regarding CI to optimize our workflow.

\subsubsection{SonarQube}
SonarQube makes static code analysis and reports bugs and vulnerabilities.
On the client side, code was analyzed successfully with SonarQube by the CI process.
If the code contained any TypeScript errors, an error was thrown and the build failed \cite{sa}. \glsadd{sonar}\\

Integration testing and code analysis on the server side by SonarQube remained pending \cite{sa}.
By splitting the client and server parts into separate git repositories,
it should be easier to isolate, analyze and fix the remaining problem of a missing SonarQube report for the language server part.

\subsubsection{Tests}
The client's end-to-end tests, provided by the prototype could not be integrated, due to their heavy dependencies.
This issue has to be re-visited at a given time. \\

On the server side, the project was automatically built by the CI server using \textit{MSBuild}.
Unit tests were executed using the \textit{nUnit} console runner \cite{nunit}.
Dafny-internal tests are run using the runner \textit{lit} \cite{lit}.

\subsubsection{Docker}
The CI server bases on a Docker distribution.
Docker's lightweight virtualization is ideally suited to run the CI environment. \glsadd{docker}\\

Docker also realizes the principle "Cattle, not pets" with docker \cite{pets-vs-cattle}.
Instead of having certain package dependencies that need to be updated continuously (pet), a "build, throw away, rebuild" procedure (cattle) is used.
This way, the dependent packages will always be up to date and security patches and the like are automatically deployed.\\

Excluded from this principle are \textit{Node}, \textit{Z3}, \textit{Go}, \textit{Boogie} and \textit{Sonar}.
All of these have to be installed in specific release versions by the CI server.
This is, since Dafny relies on specific deployments of these products.
See the developer documentation for more details \cite{dev}.\\

While working on the prototype, adjustments to the Docker image were very cumbersome.
For each change, a separate commit was made to test if the pipeline would run to success.
On the one hand this was very time-consuming as the completion of each pipeline hat to be awaited on the CI server,
on the other hand this resulted in an unpleasant commit history.
To test changes more efficiently and allow local testing without commits,
a developer-friendly way should be found and documented.

\subsubsection{Security Aspects}
The Sonar report states some issues that the usage of launch arguments may be unsafe.
However, since server and plugin run on the same machine, no active threat to a remote system exists.
Thus, a special focus on application security is not necessary.
