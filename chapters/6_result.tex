\section{Results}
\label{section:results}
\intnote{bei der SA hatte er hier gesagt: was wir unter result hatten ist 'user guide' und was wir unter conclusion hatten war results. wir dürfen hier wohl drum schon kritisch die features ansehen. dann können wir bei conclusion eher so 'es hat spass gmacht und war eine etolle erafhrung mimi fühlsch mi gsürsch mi' - ich glabu das erwartet er eher. und vlt noch so outlook und so bei conclusion - ake 'jetzt ist es einfacher, neue ffeatures hinzuzufügen,w eil die symboletable so geil ist'.}
In this chapter, the achieved results of our work are described and critically reflected.
The current version of the plugin supports numerous features:
\begin{enumerate}
    \item Syntax Highlighting
    \item Code Verification
    \item Compilation
    \item Counter Example
    \item Hover Information
    \item Goto Definition
    \item Rename
    \item Code Lens
    \item Autocompletion
    \item mehr?
\end{enumerate}


Aside the features, also architectural improvements are discussed,
which facilitate further development of the project for other developers.


\subsection{Accessibility}
Some of the features are just active by default, namely the syntax highlighting and the code verifiction.
Hover information triggers everytime the user moves his mouse over a symbol.
This should happen by chance, or by accident.
Auto completion triggers whenever the user enters a dot or types a \code{new} and will thus be discovered automatically.
Furthermore, the user can type \code{CTRL+Space} to trigger auto completion.
Further functionality, such as goto definition, compile or rename, can be accessed via the context menu.
Within the context menu, hotkeys are displayed, thus the user automatically learns how to increase his efficiency.

Although there are a lot of different features, they are visible and perceivable to the enduser without the necessity of a tutorial.
The user can start right away. \intnote{Ref auf usability tests. evtl noch ein bisschen mehr 'es ist voll geil zugänglich'}.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{results/context_menu.png}
    \caption{Plugin Context Menu}
    \label{fig:result_contextmenu}
\end{figure}

\subsection{Intro}
hier noch so:
feature sind über context menü erreichbar
hotkey einsehbar -> automatisches user learning für faster feature access
-> user sieht auch, was es alles so gibt
voll geil.
advanced shit, wie etwa farbe konfigurierbarkeit, launcha arguments, lo gplacement ist dann im readme.md für die advanced user, sodass der otto normalo SE2 student nicht überflutet wird.

andere feautres laufen einfach so, wie etwa syntax und veri

\subsection{Sntax Highlighting}
\label{section:result_syntaxhighgliht}
Syntax highlighting is realized by a given Dafny grammar file.
The file contains regex expressions defining the highlights.
It is provided by Dafny \intnote{link reffen, ich find den link nicht} and could simply be downloaded.
The feature was already implemented in the preceding term project \cite{sa}, thus no further actions had to be done.
The following screenshot shows how syntax highlighting looks inside Visual Studio Code.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{results/syntax_highlighting.png}
    \caption{Syntax Highlighting}
    \label{fig:result_syntax_highlight}
\end{figure}

As you can see, keywords like method, returns, requires and ensures are marked in purple.
Types like int are printed in blue and comments become green. Symbols, such as classes and
methods, are displayed in a brownish color. Just these simple rules increase the readability
significantly.


\subsection{Verification}
Verification was already implemented in the preceding project \cite{sa}.
Previously, the feature held some major flaws.
It only reporoted logical errors.
Syntax errors were not reported.
The code just invoked the preexisting Dafny Translation Unit, taken over by the original project \cite{ba}.
Errors reported by Dafny were no longer respected.
Only errors reported by Boogie were be tapped and reported to the user.

Verification was reworked completely in course of this bachelor thesis.
First of all, Dafny code it self was analyzed to get a better understanding of how Dafny compiles its code and how errors are reported.
Those errors could finally directly be extracted out of the Dafny error reporting engine.
Thus, the user is now informed not only about logical errors, but also about syntax errors.
Furthermore, warnings and information diagnostics are now also reported.
This is something the original project \cite{ba} did not do and was actually already issued on the official Dafny git repository \cite{dafny_noWarnings}.

The feature directly invokes Dafny's compile engine, thus is quite solid and scales automatically with future Dafny features.

\intnote{Screnshot mit warning... ich krieg kein unreachable code warning hin wtf xD}

\intnote{noch todo im code: Ganzer Block underlined oder immer noch nur das \{? hier noch ergänzen oder 'gekonnt verschweigen'}

\subsection{Compile}
The compile feature is strongly connected to the verification process.
Prior to compilation, the whole Dafny project has to be verified anyway.
Thus, since verification yields a precompiled \code{DafnyProgram}, the buffered result can be used to invoke the Dafny compiler.
This makes the compilation process very snappy and responsive.
If the code contains errors, the verificaiton process already failed and compilation can instantly be denied.
However, if the code is fine, the precompiled \code{DafnyProgram} just has to be translated, which can be done relatively fast.

The user also has the option to apply custom compilation arguments.
These can be directly set within VSCode.
\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{results/compile_customarg.png}
    \caption{Custom Compilation Arguments}
    \label{fig:compilation_custom_args}
\end{figure}

These are directly handed to the Dafny options parser and are directly applied within the Dafny engine.
Since compilation uses the precompiled Dafny program, compilation arguments that would actually affect the verification process have no effect.
This is something that could be resolved by just restarting the verification process if custom arguments were given.
Unfortunately, due to the hard project deadline, this could not be implemented anymore.

Previously, compilation was implemented so that it just started a subprocess, launching \code{Dafny.exe} with any custom arguments given.
This solution was obviously not integrated at all.
To obtain compilation results, the console output of the subprocess was parsed and reported to the user.

The current implementation is completely integrated, both, in terms of invocation and result reporting.

\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{results/compile_contextMenu_feedback.png}
    \caption{Compilation Context Menu and User Feedback}
    \label{fig:compilation_stuff}
\end{figure}


A little flaw of this feature is, that if the user chooses the option to \code{Compile And Run}, while the compilation process finishes very quickly, the actual launch of the executable takes quite some time.
However, this is nothing in scope of the language server.
If the executable is launched manually within an other console outside of Visual Studio Code, it also takes quite some time until the program starts.

\subsection{Counter Example}
Providing counter examples was already possible in the previous projects.
A major flaw was, that the representation of the counter example was quite complex and not intuitively readable.
Thus, it was a goal to ease the counter example representation.

For this, the related \code{model.bvd} file was studied.
It is a quite cryptic file and getting a full understanding of it would be very complex.
However, an \code{inital state} was located which seemed exactly that part of information, that the user is intersted in.
Thus, unlike previous versions, only that \code{initial state} is considered in counter examples.
Furthermore, any unreadable representations such as \code{**myVar} or \code{TU!Val23} were ommitted.
To allow the user to catch the information at first sight, obsolete brackets are also removed, and the minus sign is directly moved to the number.
The expression \code{((- 23))} is therefore reformated into \code{-23}, making the term much more perceiveable.

\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{results/ce_beforeafter.png}
    \caption{Counter Example Representation before (top) and after (bottom)}
    \label{fig:ce_beforeafter}
\end{figure}

Figure \ref{fig:ce_beforeafter} shows a comparison of the counter example feature between the initial state and at the end of the project.
The representation is much cleaner and easier to catch.
Also note, that more room is given so that is does not have a clumsy effect on the user's eye. \intnote{die HCID Trulla reffen? Mehr raum?}

This feature was also improved on the client side.
The user has the option to configure the color scheme of the counter example representation, if he does not like the default colors.
The default colors are chosen with respect to the user's base color theme (dark or light mode).
The counter example will correctly adjust if the user continues to work on the code and vanish, once the problem is resolved.
If the user switches between windows, the counter example state is buffered, so that once the user switches back to the original window, the counter example will be shown again.



\subsection{Hover Information}
Hover information displays a set of information, whenever the user hovers with his mouse cursor over a code symbol.
The feature itself was very simple to implement, since it basically just asks the newly implemented symbol table engine, what symbol at the cursor position is, and finally displays some information about the symbole.
It was taken as an exemplary feature, to show off how easy some LSP functionality can now be implemented using the new symbol table.
Similar to hover information, other features like text hihglighting could be added as well, which is discussed in chapter \ref{section:conclusion}.
Hover may not provide much useful information to the user, but still can be used for debugging.
For example, in figure \ref{fig:hover} the user can actually find out, where his symbol \code{field} is declared if he is unsure or what type it has.

\begin{figure}[h]
    \centering
    \includegraphics{results/hover.png}
    \caption{Hover Information Example}
    \label{fig:hover}
\end{figure}

\subsection{Goto Definition}
Goto Definition is also a very simple feature.
Similar to hover information, it will just ask what symbol is at the cursor's location.
Then, it will request the symbol table backend to report the declaration of that symbol.
Finally, the declaration origin location is returned to the lsp and the cursor jumps to it.
To increase the user experience a bit further, notificaitons are sent to the user if the symbol was already a declaration, or if there is no valid symbol at the cursor posiition.
\begin{figure}[h]
    \centering
    \includegraphics{results/goto.png}
    \caption{Goto Definition Error Reporting}
    \label{fig:goto}
\end{figure}

\intnote{die msg tut iwie nich xD is aber my bad hab da noch was geändert kürzlich. punkt 2: vscode reported das grad selber bei return null, damüssen wir unsere eigene notification eig net bringen.}

Jumps can also be done accross different files.
If the proper file is not opened, VSCode will just open it inside the workspace.
It is also possible to go to the defintion of \code{this}-Expressions, which will just jump to the class definition.
The feature works also accross code that is not within a blockstatement, for example for expressions occuring inside an \code{ensures}-clause.

Compared to the original implementation, goto definition has been significantly improved.
Prior to this bachelor thesis, the feature just scanned all code for the first name-match and reported it as the definition.
This did neither work if multiple symbols with the same name occured, nor if the declaration was placed after the first usage in the code.
Both cases are now handled well by the symbol table generator.

Runtime could also be improved, since the symbol table generator scans for possible declarations scope by scope, and doesn't just iterate over all symbols.
Last but not least, the cursor had to be at the beginning of a symbol to actually recognize the cursor position at all.
This has also been improved and the cursor can now be at any spot within a symbol.

Technically, the feature is misnamed.
A better name would actually be \code{Goto Declaration}, since it jumps to the symbol declaration, not definition.
LSP would even offer a dedicated handler for \code{textDocument/declaration} \cite{lspspec}.
\intnote{ich würd das so lassen aebr technisch gesheen müssten wir genau das implementierte interface ändern, der rest ist eh gleiich xD vlt könnte mand as sogar noch schnell machen}

\subsection{Rename}
Rename is a feature that could only be added, since the symbol table provides all necessary information.
Just like hover and goto, the feature itself is very simple.
Again it requests the symbol table at the cursor posiiton from the symbol table.
Then all occurences of that symbol are demanded and that is already all information needed.
Finally, a proper LSP response has to be assembled and is sent back to the client.

We also tried to providee as much user experience as possible for this feature, even if it is relatively simple.
In particular, this means if there is no renamable symbol at the cursor, the user is informed by a notification.
The algorithm will also check, if the new symbol name is valid.
This means, it must not start with an underscore or it must not be any reserved Dafny word.
Also, we limited the allowed new name to alphanumerical characters, although wild unicode names would be allowed by Dafny.

This could even be driven further. For example, it coul be checked, wheater a symbol with the same new name already exists.
Functionality for this is already available by the symbol table, since something similar is needed by autocompletion.
Furthermore, it is currently not checked, if the new symbol name starts with a number, which is prohibited.
That is also something that could easily be added. \intnote{das sind so one-liner im code... könnten wir echt nochs chnell umsetzen}

Since Dafny reserved words may change in the future, the wordlist is configurable for the enduser by adjusting a config file.
The process targets more advanced useres and is described in the readme file.

Since the symbol table reports occurences accross imported file as well, the rename feature works fine accross multiple files.



\subsection{CodeLens} 

\subsection{Automatic Code Completion}

\subsection{Symbol Table}
All of the previous features, with the exception of auto completion, do not contain much logic theemselves.
They just request information from the symbol table and report it back to the client.
While the features are implemented quite robust, they only work as long as the symbol table provides proper information.

Whenever the symbol table fails, the underlying features will also produce nonsense.
Thus, a correct symbol table is very important for a nice functionality.

Dafny is a programming language offering a lot of features.
Aside common object oriented features, also functional programatic features are present.
Figuer \ref{fig:DafnyAST} shows all classes occuring inside the Dafny AST.
The writers are well aware, that the text in this figure is too small to be read.
The figure should  show how many AST-elements are actually present in Dafny.
Many of them are not just inheriting from \code{Expression} or \code{Statement}, but from individual base classes.
Thus, implementing the visitor for all of them would have been too time consuming.
Since the bachelor thesis has a limited time frame, it was necessary to limit the amount of Dafny language features we support.
We decided to lay our focus on the Dafny tutorial, which is done within the software engineering at HSR.
This way, the basic concepts of Dafny are supported.
However, as soon as the user starts to use more advanced language features, a symbol may be introduced within a scope that is not visited by the visitor.
If the user is using that symbol later on inside a common method body, the symbol table generator will be unable to locate the symbol's declaration and thus fail.
An overview of the supported expressions and statements was given in chapter \ref{section:analysis_dafnyASTStuff}.

\intnote{würd hjier nciht schreiben, was genau failed, oder? weil das fägnt schon bei arrays oder listen an. iwo bei implemetnation ahben wir ja geschrieben, was wir analyisert ahebn.}

It is subject of further development, to complete the symbol table.
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{results/symboltable_dafnyast.png}
    \caption{All Dafny AST Classes}
    \label{fig:dafnyASTOverview}
\end{figure}



\subsection{Platform Independence / Mono Support for macOS and Linux}
\intnote{welcher titel ist besser?}
Eines der Kernzeiele war es, Support fuer mehrere Plattformen zu bieten. Dh nebst Windows auch macOS und Linux.
Da wir in unserer SA von Core auf Framework umsteigen musste, stand fest, dass wir mono fuer den Support auf Linux und macOS brauchen.
(warum in der SA; plficht wegen dafny core. was ist mono)

Leider funktionierts nicht.
Anssaetze die wir probiert haben. verschiedene mono versionen, angefragt im slack. antwort erhalten?
github issues: allgemein probleme mit lunux/mac weil primaer auf windows und gar nicht auf mac getestet wird. (heikle aussage selbs tmit quelle)

\cite{sa}
\cite{mono-slack}
\cite{mono-git}


\subsection{Server Architectural Improvements}
At the beginning of the thesis, the server's dependency graph was quite a mess.
During development, the code was constantly cleaned up and dependencies were resolved.

While the project is quite large and has a lot of dependencies, they could be well organized.
As seen in figure \ref{fig:dependency_graph}, all dependency are now pointing downwards, just as it should be.
Within the picture, dependencies to the Resources project are excluded for more overview.
The core layer of the project, containing \code{SymbolTable}, \code{Handler} and \code{Core}, have some sidewards dependencies, which could not be avoided completely, since these packages are strongly coupled.

Aside the grob architectural layout, many small refactorings were made to keep the code clean.
This includes the creation of smaller classes and smaller methods with single responsibilities.
A good example for this is the config reading, which was one single large class at first. \intnote{evtl lassen oder weg, ka wie ich das noch refactftore und ob überhaupt.}