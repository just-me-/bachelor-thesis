\section{Design}
This chapter contains discussions of fundamental design decisions.
It is primarily divided into client and server architecture.

\subsection{Client}
The client part of our bachelor thesis includes the VSCode plugin written in TypeScript.
It starts the Language Server and establishes a connection via LSP.\\

Since most of the logic should be kept in the IDE independent Language Server,
we have made it our goal to keep the client logic to a minimum.
This allows to implement a later plugin for another IDE with as little effort as possible. \\

In the following we will discuss how we achieved this lightweight,
and how and why we decided to split the components in the client part like we did.

\subsubsection{Initial Situation}
Already in our term project we made revisions on the client.
We have connected our new Language Server and greatly reduced the unnecessary logic.
The following figure \ref{fig:client_then} gives an impression of the architecture.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{client_then}
    \caption{Client Architecture - Term Project}
    \label{fig:client_then}
\end{figure}

In this simplified representation, the client architecture appears very tidy.
Unfortunately, the individual components are very large,
almost all members are public and this leads to high coupling and deep cohesion.
Furthermore, there are many helper classes that are not grouped into sub-packages.
This makes it difficult for other programmers to get into the project. Furthermore,
it was difficult to eliminate all dead code due to the non-transparent dependencies. \\

Because of these problems we decided to redesign the client itself from scratch.

\subsubsection{New Architecture}
To achieve the goal of a more manageable architecture and to reduce coupling, we have implemented the following measures.
As a first step, we aimed to divide all areas of responsibility into separate components.
We grouped the components into packages as you can see in figure \ref{fig:client_now_packages}.
These packages are discussed in the following sections. \\

Additionally we detached all logic from the extension class (the main component).
This resulted in the root directory containing only a lightweight program entry point
and the rest of the logic was split between the created packages. \\

As a little extra, each component contains code documentation to help other developers get started quickly. This is also helpful because they are displayed as hover tooltips.

\begin{figure}[H]
    \centering
    \includegraphics[width=6cm]{client_now_packages}
    \caption{Client Architecture - New Packages}
    \label{fig:client_now_packages}
\end{figure}

{\bf Extension} \textendash{}
This component is the aforementioned "main" of the plugin and serves as an entry point. The contained code has been minimized. Only one server is instantiated and started. The logic is located entirely in the server package. \\

{\bf Server} \textendash{}
The server package contains the basic triggering of the Language Server and the connection setup. In addition, all server requests, which extend the LSP by own functions, are sent to the server via this package. \\

{\bf TypeInterfaces} \textendash{}
In our new architecture we do not use the "any" type. We decide all types, in particular the types created specifically for additional functions such as results for counter examples. \\

{\bf UI} \textendash{}
The UI is responsible for all visual displays. Especially VSCode commands and context menu additions. Core components like the status bar are also included in this package. \\

{\bf LocalExecutionHelper} \textendash{}
This package contains small logic extensions like the execution of compiled dafny files. The UI package accesses this package. \\

{\bf StringRessources} \textendash{}
All text strings and command definitions are defined in this package. This package is used by the UI package. \\

In the following chapters the individual components and their contents are described in more detail.

\subsubsection{Components}
In the following figure \ref{fig:client_now_classes}, the components within the packages are also shown for a more detailed view. The contents of type interfaces and string resources have been omitted for clarity. \\

It can be seen that only compile and counterexample exist as server accesses. All other features were implemented purely through the LSP protocol without additional client logic as support. This server-side implementation via LSP is a great enrichment. For future plugin developments for other IDEs the effort is automatically eliminated.

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm]{client_now_classes}
    \caption{Client Architecture - Components}
    \label{fig:client_now_classes}
\end{figure}


Figure \ref{fig:client_now_methods} shows the public methods for the components.
All instance variables were set to private. Constructors were not included for simplicity. The contents of type interfaces and string resources were also omitted for clarity

\begin{figure}[H]
    \centering
    \includegraphics[width=16.5cm]{client_now_methods}
    \caption{Client Architecture - Components and Public Methods}
    \label{fig:client_now_methods}
\end{figure}

There is also a compromise that we have made.
This distribution has certain upward dependencies, which is not perfect.
The UI package accesses the server requests to be exact.
Nevertheless, we have decided on this grouping,
so that the server access functionality is encapsulated.

\subsubsection{Logic}
The logic contained in the client has been reduced to a minimum.
This mainly with the goal of making porting to other IDEs as easy as possible.
This subchapter describes in rough outlines the logic still contained in the client and its benefits.  \\

{\bf Server Connection} \textendash{}
Starting the Language Server and send API requests. In addition, the client has a simple logic that
certain server requests (such as updating the counter example) are sent a maximum of twice per second. \\

{\bf Execute Compiled Dafny Files} \textendash{}
The execution of compiled Dafny files is relatively simple. One distinguishes whether the execution
of .exe files should be done with mono (on macOS and Linux operating systems) or not. \\

{\bf Notifications} \textendash{}
The client allows the Language Server to send certain messages which are displayed directly to the user as a popup.
These include the types information, warning and error.
The corresponding logic on the client side includes the registration of the interception on the server
and the corresponding method calls of the VSCode API to display the messages. \\

{\bf Commands} \textendash{}
To enable the user to actively use features (such as compile),
the corresponding method calls must be linked to the UI.
We have three primary links for this: Supplementing the context menu (right-click),
shortcuts and entering commands via the VSCode command line. \\

{\bf Statusbar} \textendash{}
The information content for the Statusbar is delivered completely by the Language Server.
The client only takes care of the user friendly display with icons and help texts.
Therefore certain event listeners must be registered, which react to the server requests.
Furthermore the received information is buffered for each Dafny file.
This allows the user to switch seamlessly between Dafny files in VSCode
without having the server to send the status bar information
(like the number of errors in the Dafny file) each time.  \\

{\bf Counter Example} \textendash{}
The Counter Example has a similar buffer as the Statusbar.
For each dafny file in the workspace a buffer stores if the user wants to see the Counter Example.
This way the Counter Example is hidden when the user switches to another file
and automatically shown again when switching back to the previous Dafny file. 

\subsection{Integration Tests}
Unlike in the preceding semester thesis, integration tests could be implemented using Omnisharp's Language Server Client \cite{omnisharpClient}. Each test starts a language server and a language client, then they connect to each other. Now, the client can send supported requests, for example "get me the counter examples for file ../test.dfy". The result can be directly parsed into our \code{CounterExampleResults} datastructure and be compared to the expectation. Thus, tests can be written easily and are very meaningful and highly relevant.

\subsubsection{Dafny Test Files}
Integration Tests usually run directly on \code{dfy} sourcefiles. Those testfiles need to be referenced from within the test. To keep the references organized, a dedicated project \code{TestCommons} was created. Each test project has access to these common items. Every testfile is provided as a static variable and can thus be easily referenced.
\lstset{style=sharpc}
\begin{lstlisting}[caption={Test File Reference}, captionpos=b, label={lst:fileRef}]
public static readonly string cp_semiexpected = CreateTestfilePath("compile/semi_expected_error.dfy");
\end{lstlisting}
The class providing these references will also check, if the test file actually exists, so that \code{FileNotFoundErrors} can be excluded.

\subsubsection{String Converters}
Many tests return results in complex data structures, such as \code{CounterExampleResults}. Comparing these against an expectation is not suitable, since many fields and lists had to be compared to each other.\\
To be able to easily compare the results against an expectation, a converter was written to translate the complex data structure into a simple list of strings. For example, each counter example will be converted into a unique string, containing all information about the counter example. All counter examples together are assembled within a list of strings. This way, they can be easily compared against each other.\\
Since not only counter examples, but also other data structures such as \code{Diagnostic} were converted into lists of strings, the converters were held generic as far as possible. The following listing shows how this was realized. The method takes a enumerable of type T as an argument, and a converter which converts type T into a string. Each item in the enumerable is then selected in the converted variant.

\begin{lstlisting}[caption={Generic Method to Convert an IEnumerable}, captionpos=b, label={lst:fileRef}]
private static List<string> GenericToStringList<T>(this IEnumerable<T> source, Func<T, string> converter)
{
    return source?.Select(converter).ToList();
}
\end{lstlisting}

Calling the above method for counter examples are made as follows. A list of counter examples is handed as the argument, and a \code{Func<CounterExample, string> ToCustomString} is handed as the converter. The converter is also shown in the following code segment. Not that it is defined as an extension method.

\begin{lstlisting}[caption={Converting CounterExamples to strings}, captionpos=b, label={lst:fileRef}]
public static List<string> ToStringList(this List<CounterExample> source)
{
    return GenericToStringList(source, ToCustomString);
}

public static string ToCustomString(this CounterExample ce)
{
    if (ce == null)
    {
        return null;
    }
    string result = $"L{ce.Line} C{ce.Col}: ";
    result = ce.Variables.Aggregate(result, (current, kvp) => current + $"{kvp.Key} = {kvp.Value}; ");
    return result;
}
\end{lstlisting}

Comparison of the results and the expectation is now very simple. The expectation can just be written by hand as follows:

\begin{lstlisting}[caption={Expectation}, captionpos=b, label={lst:testexpectation}]
List<string> expecation = new List<string>()
{
    "L3 C19: in1 = 2446; ",
    "L9 C19: in2 = 891; "
};
\end{lstlisting}

The results can be converted to a string list using the defined \code{results.ToStringList()} method. By taking advantage of the method \code{CollectionAssert.AreEquivalent(expectation, actual)} from nUnit's test framework, the two lists can be easily compared against each other \cite{nunitCollectionAssert}.

\section{Test Architecture}
Since every integration test starts the client and the server at first, as well as disposes them at the end, this functionality could be well extracted into a separate base class. This class is called \code{IntegrationTestBase} and just contains two methods, \code{Setup} and \code{Teardown}. These methods could be directly annotated with the proper nUnit tags, so that every test will at first setup the client-server infrastructure, and tear it down after the test has been completed.\\
It was considered if the \code{IntegrationTestBase} class should directly contain a class member \code{T TestResults} to store the test results, as well as a method \code{SendRequest} and \code{VerifyResults}. While storing the test results could have been realized, this was not possible for the methods \code{SendRequest} and \code{VerifyResults}. The problem is, that these methods have different signatures from test case to test case. A compilation requests has differnt parameters (such as compilation arguments), than a goto-defintion request (which as a position as a parameter).\\
Instead, it was decided to create a second base class for each test case. For testing compilation, this class is named \code{CompileBase} as an example. It inherits from the \code{IntegrationTestBase} class and provides the member \code{CompilerResults}, as well as two methods \code{RunCompilaton(string file, string[] args)} and \code{VerifyResults(string expectation)}. One can now easily see the dedicated paramter list.\\
The test class itself inherits from its case-specific base class. The tests itself are very simple. For example, if we want to test if the compiler reports a missing semicolon, we could create a testclass \code{public class SyntaxErrors : CompileBase}. Note that we inherit from hour case-specific base class. Thus, the methods \code{RunCompilation} and\code{Verify} are at our dispoal. That means, that hour test is as simple as follows:
\begin{lstlisting}[caption={Sample Test for Missing semicolon}, captionpos=b, label={lst:demoTest}]
[Test]
public void FailureSyntaxErrorSemiExpected()
{
    RunCompilation(Files.cp_semiexpected);
    VerifyResults("Semicolon expected in line 7.");
}
\end{lstlisting}
As you can see, the test contains only of two lines of code. The first handing in the test file, the second one definind our expectations. By the way, the boolean values represent if there were errors and if an executable was generated.\\
The same applies for test about counter examples, goto definition and other use cases. Thus, the integration test architecture could be created in a way so that the creation of tests is extremely simple and user friendly. The code can be kept very clean and contains no duplicated code. Tests can easily be organized into classes \textendash{} considering compilation this could for example be the separation into logical errors, syntax errors, wrong file types and such.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{integrationTestDesign}
    \caption{Test Architecture on the Basis of Compilation}
    \label{fig:testArchitecture}
\end{figure}








