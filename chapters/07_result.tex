\section{Results}
\label{section:results}

für benutzer, programmierer vo dafny
für pugin / anguage server weiterentickler
plugin ide support andere
persönliches ziel - mehrwert der arbeit für die gesellschaft; veröffentlichung
---


As described in our objectives, our work has three basic stakeholders. \\

On the one hand there are the students of the HSR, who want to develop with Dafny.
For these students a usefull plugin should be offered to make the development with Dafny source code easier. \\

On the other hand, it is the developers who want to further develop our Language Server in order to offer additional features to users.
This category also includes developers who want to make other IDE's compatible with new plugins for Dafny in addition to VS code.
For developers the further development should be kept as simple as possible. \\

Last but not least, we - the authors of this thesis - also belong to the interest group.
Since we wanted to make a contribution to society with our work,
it was always a big concern for us to achieve a stable version of the plugin, which we can also publish.
This way Dafny developers can get a real use for the plugin. \\

The following subchapters describe the results achieved and further prospects for each target group.

\subsection{Features for Dafny Developers}
In this subchapter, the achieved feature set of the project is described and critically reflected.
The current version of the plugin supports the following features for Dafny developers in VS Code:
\begin{enumerate}
    \item Syntax Highlighting
    \item Code Verification
    \item Compilation
    \item Counter Example
    \item Hover Information
    \item Go to Definition
    \item Rename
    \item Code Lens
    \item Autocompletion
    \item mehr? todo
\end{enumerate}

\subsubsection{Accessibility}
Some of the features are just active by default, namely syntax highlighting and code verification.
The user perceives these features without any actions necessary.\\

Hover information triggers every time the user moves his mouse over a symbol.
This should happen by chance, or by accident.\\

Auto completion triggers whenever the user enters a dot or types a \code{new} and will thus be discovered automatically. \intnote{stimmt das überhaupt? noch ned aber sollte noch gm usability test}
Furthermore, the user can type \code{CTRL+Space} to trigger auto completion.
Further functionality, such as go to definition, compile or rename, can be accessed via the context menu.
Within the context menu, hotkeys are displayed, thus the user automatically learns how to increase his efficiency.

Although there are a lot of different features, they are visible and perceivable to the end user without the necessity of a tutorial.

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm]{results/context_menu.png}
    \caption{Plugin Context Menu}
    \label{fig:result_contextmenu}
\end{figure}

More advanced features that do not target the every day user are described in the \code{readme.md} file.
These include:
\begin{itemize}
    \item Configuring colors
    \item Setting language server arguments
    \item Editing the language server config
\end{itemize}

\subsubsection{Syntax Highlighting}
\label{section:result:syntaxhighgliht}
Syntax highlighting is realized by a given Dafny grammar file.
The file contains regex expressions defining the highlights.
It is provided by Dafny \intnote{link reffen, ich find den link nicht} and could simply be downloaded.
The feature was already implemented in the prototype, thus no further actions had to be done.
The following screenshot shows how syntax highlighting looks inside Visual Studio Code.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{results/syntax_highlighting.png}
    \caption{Syntax Highlighting}
    \label{fig:result_syntax_highlight}
\end{figure}

As you can see, keywords like \textit{method}, \textit{returns}, \textit{requires} and \textit{ensures} are marked in purple.
Types like int are printed in blue and comments become green.
Symbols, such as classes and methods, are displayed in a brownish color.
Just these simple rules increase the readability significantly.

\subsubsection{Verification}
Verification was already implemented in the prototype, too.
At the start of the project, the feature held some major flaws.
It only reported logical errors.
Syntax errors were not announced.
The code just invoked the \code{DafnyTranslationUnit}, taken over by the pre-existing project.\\

Verification was reworked completely during this project.
First of all, Dafny code itself was analyzed to get a better understanding of how Dafny compiles its code and how errors are reported.
Those errors could finally directly be extracted out of the Dafny error reporting engine.
Thus, the user is now informed not only about logical errors, but also about syntax errors.
Furthermore, warnings and information diagnostics are now also reported.
Reporting warnings something the pre-existing project did not do and was actually already issued on the official Dafny git repository \cite{dafny_noWarnings}.
With the symbol table, it is now also possible to underline complete code blocks, instead of just single symbols which were barely visible at the beginning of the project.
This shows well how the quality of the tool could be improved.\\

The feature directly invokes Dafny's compile engine, thus works quite solid and scales automatically with future Dafny features.

\begin{figure}[H]
    \centering
    \includegraphics[width=15cm]{results/warningAndInformation.png}
    \caption{Reporting of Warnings and Information Objects}
    \label{fig:result_warnd_info}
\end{figure}

\subsubsection{Compile}
The compile feature is strongly connected to the verification process.
Prior to compilation, the whole Dafny project has to be verified anyway.
Thus, since verification yields a precompiled \code{DafnyProgram}, the buffered result can be used to invoke the Dafny compiler.
This makes the compilation process very snappy and responsive.\\

If the code contains errors, the verification process already failed and compilation can instantly be denied.
However, if the code is fine, the precompiled \code{DafnyProgram} just has to be translated, which can be done quickly.

The user also has the option to apply custom compilation arguments.
These can be directly set within VSCode.
\begin{figure}[H]
    \centering
    \includegraphics[width=15cm]{results/compile_customarg.png}
    \caption{Custom Compilation Arguments}
    \label{fig:compilation_custom_args}
\end{figure}

Custom arguments are directly handed to the Dafny options parser and are applied within the Dafny engine.
Since compilation uses the precompiled Dafny program, compilation arguments affecting the verification process have no effect.
This is something that could be resolved by just restarting the verification process if custom arguments were given.\\

In the prototype, compilation was implemented by just starting a sub-process, launching \code{Dafny.exe} with custom arguments given.
To obtain compilation results, the console output of the sub-process was parsed and reported to the user.
That solution was obviously not integrated at all.
The current implementation improved that significantly, is now completely integrated, both, in terms of invocation and result reporting.

\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{results/compile_contextMenu_feedback.png}
    \caption{Compilation Context Menu and User Feedback}
    \label{fig:compilation_stuff}
\end{figure}


If the user chooses the option to \code{Compile And Run}, the actual launch of the executable takes quite a long time - up to about 10 seconds.
However, this delay is not related to the language server or the compilation process.
If the executable is launched manually within another console outside of Visual Studio Code, it also takes long until the program starts.
The effect just occurs the first time an executable is launched.
The reason for that could not be investigated.

\subsubsection{Counter Example}
Providing counter examples was already possible in the prototype.
A major flaw was, that the representation of the counter example was quite complex and not intuitively readable.
Thus, it was a goal to ease the counter example representation.\\

For this, the related \code{model.bvd} file was studied.
It is quite a  cryptic file and getting a comprehensive understanding of it would be very complex.
However, an \code{inital state} was located which seemed exactly that part of information, that the user is interested in.
Thus, unlike previous in versions, only that \code{initial state} is considered in counter examples.
Furthermore, any unreadable representations such as \code{**myVar} or \code{TU!Val23} were omitted.
To allow the user to catch the information at first sight, obsolete brackets are also removed, and the minus sign is directly moved to the number.
The expression \code{((- 23))} is therefore reformatted into \code{-23}, making the term much more perceivable.

\begin{figure}[h]
    \centering
    \includegraphics[width=10cm]{results/ce_beforeafter.png}
    \caption{Counter Example Representation before (top) and after (bottom)}
    \label{fig:ce_beforeafter}
\end{figure}

Figure \ref{fig:ce_beforeafter} shows a comparison of the counter example feature between the initial state and at the end of the project.
The representation is much cleaner and easier to immerse.
Also note, that more room is given so that is does not have a clumsy effect on the user's eye. \intnote{die HCID Trulla reffen? Mehr raum?}

This feature was also improved on the client side.
The user has the option to configure the color scheme of the counter example representation, if he does not like the default colors.
The default colors are chosen with respect to the user's base color theme of VSCode (dark or light mode).
The counter example will correctly adjust if the user continues to work on the code and vanish, once the problem is resolved.
If the user switches between windows, the counter example state is buffered, so that once the user switches back to the original window, the counter example will be shown again.

\subsubsection{Hover Information}
Hover information displays a set of information, whenever the user hovers with the mouse cursor over a code symbol.
The feature itself was very simple to implement, since it receives all necessary information from the symbol table.
It was additionally implemented as an exemplary feature, to show off how easy some LSP functionality can now be implemented using the new symbol table.
Similar to hover information, other features like text highlighting can be added as well in the future, which is discussed in chapter \ref{section:conclusion}.
Hover may not provide much useful information to the user, but it is still a nice gimmick.
For example, in figure \ref{fig:hover} the user can actually find out, where his \code{field} is declared if he is unsure.

\begin{figure}[h]
    \centering
    \includegraphics{results/hover.png}
    \caption{Hover Information Example}
    \label{fig:hover}
\end{figure}

\subsubsection{Go to Definition}
Compared to the prototype, go to definition has been significantly improved.
Prior to this bachelor thesis, the feature just scanned all code for the first name-match and reported it as the definition.
This did neither work if multiple symbols with the same name occurred, nor if the declaration was placed after the first usage in the code.
Both cases are now handled well by the symbol table engine.\\

Runtime could also be improved, since the symbol table generator scans for possible declarations scope by scope, and doesn't just iterate over all symbols.
Last but not least, in the prototype, the cursor had to be at the beginning of a symbol to recognize the symbol at all.
This major flaw has of course been overcome.
The cursor can now be at any character within a symbol.\\

Technically, the feature is misnamed.
A better name would actually be \code{Go to Declaration}, since it jumps to the symbol declaration, not definition.
LSP would even offer a dedicated handler for this, \code{textDocument/declaration} \cite{lspspec}.
\intnote{ich würd das so lassen aebr technisch gesheen müssten wir genau das implementierte interface ändern, der rest ist eh gleiich xD vlt könnte mand as sogar noch schnell machen
VSCode nennt das aber auch Go to Definition (ja, weil der deinition handler implemented ist xD) Müssen wir das überhaupt erwähnen? einfach streichen husthust? erwähnen würd ich es aber tatsächlich, weil ich find das jetzt nicht so tragisch /schlimm. aber ich schau nächste woche mal noch, je nachdem ist das wirklich eine 2min arbeit. aber wenn dann alle grafiken und bla anders isnd, n ja. mal schauen.}

To increase the user experience with this feature, notifications are sent to the user if an error occurred or the requested symbol was already a declaration.r
\begin{figure}[h]
    \centering
    \includegraphics{results/goto.png}
    \caption{Goto Definition Error Reporting}
    \label{fig:goto}
\end{figure}

\intnote{die msg tut iwie nich xD is aber my bad hab da noch was geändert kürzlich. punkt 2: vscode reported das grad selber bei return null, damüssen wir unsere eigene notification eig net bringen.}

Jumps can also be done across different files.
If the proper file is not opened, VSCode will just open it inside the workspace.
It is also possible to go to the definition of \code{this}-Expressions, which will just jump to the class definition.
The feature works also across code that is not within a block statement, for example for expressions occurring inside an \code{ensures}-clause.


\subsubsection{Rename}
Rename is a feature that could only be added, since the symbol table provides all necessary information.

It was embraced to provide as much user experience as possible for this feature, even if it is relatively simple.
In particular, this means if there is no renamable symbol at the cursor, the user is informed by a notification.
The algorithm will also check, if the new symbol name is valid.
This means, it must not start with an underscore or it must not be any reserved Dafny word.
Also, we limited the allowed new name to alphanumerical characters, although wild unicode names would be allowed by Dafny.

This could even be driven further.
For example, it could be checked, whether a symbol with the same new name already exists.
Functionality for this is already available by the symbol table, since something similar is needed by autocompletion.
Furthermore, it is currently not checked, if the new symbol name starts with a number, which is prohibited.
That is also something that could easily be added. \intnote{das sind so one-liner im code... könnten wir echt nochs chnell umsetzen}

Since Dafny reserved words may change in the future, the wordlist is configurable for the end-user by adjusting a config file.
The process targets more advanced users and is described in the readme file.

Since the symbol table reports occurrences across imported files as well, the rename feature works fine across the complete workspace.

\intnote{abschnitt gefällt mir mnicht, evtl neu schreiben. ist einfach blabla mit 0 inhalt.}



\subsubsection{CodeLens}
todo überall bilder bzw platzhalter bilder einfügen .


todo

bessere anzeige, bessere laufzeit
0 -- kann gelöscht werden
1 - ingular
2 plural
 klick auf grauer text, popup geht auf. man kann sofort wie man es von codelens erwartet zu den verwendeten positionen springen sprich diese einsehen.

besser: acuh  includes files ohne main supporten.
zwei varianten in implmenentation beschreiben; hier referenzieren

\subsubsection{Automatic Code Completion}
todo
Basecase (aktueller scope)
punkt - für das symbol verfügbare methoden und variablen werden vorgeschlagen
new - nur klassen im aktuellen scope werden angezeigt

bei der einfügung einer klasse nach "new" und bei einfügung von funktionen/methoden nach punkt werden klammern gesetzt.

(krieg ich noch die anzeige von parametern hin? )
xcode sachen sind IDE abhängig. vscode bietet das nicht. man könnte diese funktion aber jedoch selbst
mit relativ hohem aufwand implementieren. beschreiben in implementation.
es is tnich tuaszuschliessen, dass dies jedoch in anderen ide's mit einem api aufruf der ide relativ simpel möglich ist.
es ist auch nicht auszuschliessen, dass vs code in zukunft ein ähniches feature selbst noch implementieren wird.
"language server bietet info für parameter - todo stimmt das?"

\subsection{Simplicity of Further Development}
Aside the features, also architectural improvements are discussed,
which increase maintainability and facilitate future extensions of the project.

\subsubsection{Symbol Table}
The symbol table was newly implemented during this project.
However, the prototype contained some symbol information that was already existing inside the pre-existing project.
That symbol table was only containing a list of strings though.
It was a very primitive approach of a symbol table.\\

The new symbol table contains proper objects.
Related information, such as the parent symbol, is now directly accessible.
Any string parsing could be completely omitted compared to the prototype.
This leads to better performance and above all to reliable symbol references.\\

All of the previous features, with the exception of auto completion, do not contain much logic themselves.
They just request information from the symbol table and report it back to the client.
While the features are implemented quite robust, they only work as long as the symbol table provides proper information.\\

Whenever the symbol table fails, the underlying features will also produce nonsense.
Thus, a correct symbol table is crucial for correct functionality.\\

Dafny is a programming language offering a lot of features.
Aside common object oriented features, also functional programmatic features are present.
Figure \ref{fig:DafnyAST} shows all classes occurring inside the Dafny AST.
The writers are well aware, that the text in this figure is too small to be read.
The figure should indicate the humungous amount of AST-elements present in Dafny.
Many of them are not just inheriting from \code{Expression} or \code{Statement}, but from individual base classes.
Thus, implementing the visitor for all of them turned out to be massively time consuming.
Since the bachelor thesis is bounded by a limited time frame, it was necessary to limit the amount of Dafny language features we support.
We decided to lay our focus on the Dafny tutorial, which is done within the software engineering at HSR.
This way, the basic concepts of Dafny are supported.
However, as soon as the user starts to use more advanced language features, a symbol may be introduced within a scope that is not visited by the visitor.
If the user is using that symbol later on inside a common method body, the symbol table generator will be unable to locate the symbol's declaration and thus fail.
An overview of the supported expressions and statements was given in chapter \ref{section:analysis_dafnyASTStuff}.\\

\intnote{würd hjier nciht schreiben, was genau failed, oder? weil das fägnt schon bei arrays oder listen an. iwo bei implemetnation ahben wir ja geschrieben, was wir analyisert ahebn. was meinst du marcel?}

It is subject of further development to complete the symbol table.
It is the first priority in further development of the language server.
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{results/symboltable_dafnyast.png}
    \caption{All Dafny AST Classes}
    \label{fig:dafnyASTOverview}
\end{figure}

\subsubsection{Server Architectural Improvements}
At the beginning of the thesis, the server's dependency graph was quite a mess.
During development, the code was constantly cleaned up and dependencies were resolved.

While the project is quite large and has a lot of dependencies, they could be well organized.
As seen in figure \ref{fig:dependency_graph}, all dependency are now pointing downwards, just as it should be.
Within the picture, dependencies to the \code{Resources} package are excluded for more overview.
The core layer of the project, containing \code{SymbolTable}, \code{Handler} and \code{Core}, have some sideward dependencies, which could not be avoided completely, since these packages are strongly coupled.

Aside the broad architectural layout, many small refactorings were made to keep the code clean.
This includes the creation of smaller classes and smaller methods with single responsibilities.
A good example for this is the config initialization, which was one single large class at first.
After refactoring, it was split into small, well organized sub-classes.

Any important classes, such as handlers, providers or classes related to the symbol table are programmed against interfaces.
This allows for optimal testing, for example by implementing the same interface with a fake instance.

\subsubsection{Client Architectural Improvements}
todo
Cleaner, kleinere componenten, bessere isolation
verwendung von interfaces, kapselung. falls logik künftig eingefügt wird und man tests schreiben möchte; geht dank interfaces relativ gut.

isolation von vscode komponenten
kann so möglichst einfach auf andere IDEs migriert werden
bsp atom... link dass es auch typescript und js verwendet...


\subsection{Publication of the Plugin}


\subsubsection{Veröffentlichung}
\intnote{todo}
- plugin live
- rebase auf server machen
- pull request dokumentieren -- signifikantes ergebnis -- man kanns verwenden

beschreiben interface download, wie das ausgetaucht werden kann.
bin hier nicht draus gekommen genau.
fabian sagt: pullt es zu mir, weil ich muss noch mono machen
corbat sagt: ja ihr müsst schreiben, dass ihr es pullt, weil dann zähtl es als public.

!!vorsicht kapitel 8 hat auh noch n absatz übers deployment (ab zeile zirka 36)


\subsubsection{Platform Independence / Mono Support for macOS and Linux}
\intnote{welcher titel ist besser? platfrîrm hier, mono bei implementation todo}
Eines der Kernzeiele war es, Support fuer mehrere Plattformen zu bieten. Dh nebst Windows auch macOS und Linux.
Da wir in unserer SA von Core auf Framework umsteigen musste, stand fest, dass wir mono fuer den Support auf Linux und macOS brauchen.
(warum in der SA; plficht wegen dafny core. was ist mono)

todo

Leider funktionierts nicht.
Anssaetze die wir probiert haben. verschiedene mono versionen, angefragt im slack. antwort erhalten?
github issues: allgemein probleme mit lunux/mac weil primaer auf windows und gar nicht auf mac getestet wird. (heikle aussage selbs tmit quelle)

ansatz in die implementation rein
ergebnis "wir habens probiert", die nächsten machen dass dann

- ms build wegen sonar, probleme in der SA mit core
dotnet build sollen wir umstellen...
unerer eig core fähig
danfy braucht bei der SA framework.. abhängigkeiten machten alles kaput, mit manuel nicht fixen können, framework genommen
inwzsichen ist diese dafny konsole / server weg weil wir das fancy gemacht haben
evt bestehen diese abhängigkeiten gar nicht mehr; umstellung auf core könnte leicht sein
mangelnde zeit daher nicht gemacht. als ausblick festhalten.

\cite{sa}
\cite{mono-slack}
\cite{mono-git}
