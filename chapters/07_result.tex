\section{Results}
\label{section:results}

 \intnote{Corbat: Da fehlt iwie ein kapitel für Comparison loc for implementation of features with symbol table present? loc symbol table?}

As described in our objectives, our work has three basic stakeholders. \\

On the one hand there are the students of the HSR, who want to develop with Dafny.
For these students a usefull plugin should be offered to make the development with Dafny source code easier. \\

On the other hand, it is the developers who want to further develop our Language Server in order to offer additional features to users.
This category also includes developers who want to make other IDE's compatible with new plugins for Dafny in addition to VS code.
For developers the further development should be kept as simple as possible. \\

Last but not least, we - the authors of this thesis - also belong to the interest group.
Since we wanted to make a contribution to society with our work,
it was always a big concern for us to achieve a stable version of the plugin, which we can also publish.
This way Dafny developers can get a real use for the plugin. \\

The following section describe the results achieved and further prospects for each target group.

\subsection{Features for Dafny Developers}
In this section, the achieved feature set of the project is described and critically reflected.
The current version of the plugin supports the following features for Dafny developers in VS Code:
\begin{enumerate}
    \item Syntax Highlighting
    \item Code Verification
    \item Compilation
    \item CounterExample
    \item Hover Information
    \item GoToDefinition
    \item Rename
    \item CodeLens
    \item Autocompletion
    \item  \intnote{mehr? todo}
\end{enumerate}

\subsubsection{Accessibility}
Some of the features are just active by default, namely syntax highlighting and code verification.
The user perceives these features without any actions necessary.\\

Hover information triggers every time the user moves his mouse over a symbol.
This should happen by chance, or by accident.\\

AutoCompletion triggers whenever the user enters a dot or types a \code{new} and will thus be discovered automatically. \intnote{stimmt das überhaupt? noch ned aber sollte noch gm usability test}
Furthermore, the user can type \code{CTRL+Space} to trigger AutoCompletion.
Further functionality, such as GoToDefinition, compile or rename, can be accessed via the context menu.
Within the context menu, hotkeys are displayed, thus the user automatically learns how to increase his efficiency.

Although there are a lot of different features, they are visible and perceivable to the end user without the necessity of a tutorial.

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm]{results/context_menu.png}
    \caption{Plugin Context Menu}
    \label{fig:result_contextmenu}
\end{figure}

More advanced features that do not target the every day user are described in the \code{readme.md} file.
These include:
\begin{itemize}
    \item Configuring colors
    \item Setting language server arguments
    \item Editing the language server config
\end{itemize}

\subsubsection{Syntax Highlighting}
\label{section:result:syntaxhighgliht}
Syntax highlighting is realized by a given Dafny grammar file.
The file contains regex expressions defining the highlights.
It is provided by Dafny \intnote{link reffen, ich find den link nicht} and could simply be downloaded.
The feature was already implemented in the prototype, thus no further actions had to be done.
The following screenshot shows how syntax highlighting looks inside Visual Studio Code.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{results/syntax_highlighting.png}
    \caption{Syntax Highlighting}
    \label{fig:result_syntax_highlight}
\end{figure}

As you can see, keywords like \textit{method}, \textit{returns}, \textit{requires} and \textit{ensures} are marked in purple.
Types like int are printed in blue and comments become green.
Symbols, such as classes and methods, are displayed in a brownish color.
Just these simple rules increase the readability significantly.

\subsubsection{Verification}
Verification was already implemented in the prototype, too.
At the start of the project, the feature held some major flaws.
It only reported logical errors.
Syntax errors were not announced.
The code just invoked the \code{DafnyTranslationUnit}, taken over by the pre-existing project.\\

Verification was reworked completely during this project.
First of all, Dafny code itself was analyzed to get a better understanding of how Dafny compiles its code and how errors are reported.
Those errors could finally directly be extracted out of the Dafny error reporting engine.
Thus, the user is now informed not only about logical errors, but also about syntax errors.
Furthermore, warnings and information diagnostics are now also reported.
Reporting warnings something the pre-existing project did not do and was actually already issued on the official Dafny git repository \cite{dafny_noWarnings}.
With the symbol table, it is now also possible to underline complete code blocks, instead of just single symbols which were barely visible at the beginning of the project as you can see in figure \ref{fig:error_whole_block}.
This shows well how the quality of the tool could be improved.

\begin{figure}[H]
    \centering
    \includegraphics[width=9cm]{results/error_whole_block.png}
    \caption{Underlinding Before (Top) and After (Buttom)}
    \label{fig:error_whole_block}
\end{figure}

The feature directly invokes Dafny's compile engine, thus works quite solid and scales automatically with future Dafny features.

\begin{figure}[H]
    \centering
    \includegraphics[width=15cm]{results/warningAndInformation.png}
    \caption{Reporting of Warnings and Information Objects}
    \label{fig:result_warnd_info}
\end{figure}

\subsubsection{Compile}
The compile feature is strongly connected to the verification process.
Prior to compilation, the whole Dafny project has to be verified anyway.
Thus, since verification yields a precompiled \code{DafnyProgram}, the buffered result can be used to invoke the Dafny compiler.
This makes the compilation process very snappy and responsive.\\

If the code contains errors, the verification process already failed and compilation can instantly be denied.
However, if the code is fine, the precompiled \code{DafnyProgram} just has to be translated, which can be done quickly.

The user also has the option to apply custom compilation arguments.
These can be directly set within VSCode.
\begin{figure}[H]
    \centering
    \includegraphics[width=15cm]{results/compile_customarg.png}
    \caption{Custom Compilation Arguments}
    \label{fig:compilation_custom_args}
\end{figure}

Custom arguments are directly handed to the Dafny options parser and are applied within the Dafny engine.
Since compilation uses the precompiled Dafny program, compilation arguments affecting the verification process have no effect.
This is something that could be resolved by just restarting the verification process if custom arguments were given.\\

In the prototype, compilation was implemented by just starting a sub-process, launching \code{Dafny.exe} with custom arguments given.
To obtain compilation results, the console output of the sub-process was parsed and reported to the user.
That solution was obviously not integrated at all.
The current implementation improved that significantly, is now completely integrated, both, in terms of invocation and result reporting.

\begin{figure}[H]
    \centering
    \includegraphics[width=10cm]{results/compile_contextMenu_feedback.png}
    \caption{Compilation Context Menu and User Feedback}
    \label{fig:compilation_stuff}
\end{figure}


If the user chooses the option to \code{Compile And Run}, the actual launch of the executable takes quite a long time - up to about 10 seconds.
However, this delay is not related to the language server or the compilation process.
If the executable is launched manually within another console outside of Visual Studio Code, it also takes long until the program starts.
The effect just occurs the first time an executable is launched.
The reason for that could not be investigated.

\subsubsection{CounterExample}
Providing CounterExamples was already possible in the prototype.
A major flaw was, that the representation of the CounterExample was quite complex and not intuitively readable.
Thus, it was a goal to ease the CounterExample representation.\\

For this, the related \code{model.bvd} file was studied.
It is quite a  cryptic file and getting a comprehensive understanding of it would be very complex.
However, an \code{inital state} was located which seemed exactly that part of information, that the user is interested in.
Thus, unlike previous in versions, only that \code{initial state} is considered in CounterExamples.
Furthermore, any unreadable representations such as \code{**myVar} or \code{TU!Val23} were omitted.
To allow the user to catch the information at first sight, obsolete brackets are also removed, and the minus sign is directly moved to the number.
The expression \code{((- 23))} is therefore reformatted into \code{-23}, making the term much more perceivable.

\begin{figure}[H]
    \centering
    \includegraphics[width=12cm]{results/ce_beforeafter.png}
    \caption{CounterExample Representation Before (Top) and After (Bottom)}
    \label{fig:ce_beforeafter}
\end{figure}

Figure \ref{fig:ce_beforeafter} shows a comparison of the CounterExample feature between the initial state and at the end of the project.
The representation is much cleaner and easier to immerse.
Also note, that more room is given so that is does not have a clumsy effect on the user's eye. \\

This feature was also improved on the client side.
The user has the option to configure the color scheme of the CounterExample representation, if he does not like the default colors.
The default colors are chosen with respect to the user's base color theme of VSCode (dark or light mode).
As in figure \ref{fig:ce_beforeafter} the light theme is shown,
the following figure \ref{fig:ce_dark} shows the dark mode colors.

\begin{figure}[H]
    \centering
    \includegraphics[width=8cm]{results/ce_dark.png}
    \caption{CounterExample Dark Theme}
    \label{fig:ce_dark}
\end{figure}

The CounterExample will correctly adjust if the user continues to work on the code and vanish, once the problem is resolved.
If the user switches between windows, the CounterExample state is buffered, so that once the user switches back to the original window, the CounterExample will be shown again.

\subsubsection{Hover Information}
Hover information displays a set of information, whenever the user hovers with the mouse cursor over a code symbol.
The feature itself was very simple to implement, since it receives all necessary information from the symbol table.
It was additionally implemented as an exemplary feature, to show off how easy some LSP functionality can now be implemented using the new symbol table.
Similar to hover information, other features like text highlighting can be added as well in the future, which is discussed in chapter \ref{section:conclusion}.
Hover may not provide much useful information to the user, but it is still a nice gimmick.
For example, in figure \ref{fig:hover} the user can actually find out, where his \code{field} is declared if he is unsure.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth/2]{results/hover.png}
    \caption{Hover Information Example}
    \label{fig:hover}
\end{figure}

\subsubsection{GoToDefinition}
Compared to the prototype, GoToDefinition has been significantly improved.
Prior to this bachelor thesis, the feature just scanned all code for the first name-match and reported it as the definition.
This did neither work if multiple symbols with the same name occurred, nor if the declaration was placed after the first usage in the code.
Both cases are now handled well by the symbol table engine.\\

Runtime could also be improved, since the symbol table generator scans for possible declarations scope by scope, and doesn't just iterate over all symbols.
Last but not least, in the prototype, the cursor had to be at the beginning of a symbol to recognize the symbol at all.
This major flaw has of course been overcome.
The cursor can now be at any character within a symbol.\\

Technically, the feature is misnamed.
A better name would actually be \code{Go to Declaration}, since it jumps to the symbol declaration, not definition.
LSP would even offer a dedicated handler for this, \code{textDocument/declaration} \cite{lspspec}.
Since VS Code names the short cut „GoToDefinition“, since the definition handler was implemented, we named that feature in our previouse theses in the same way.
We kept the name to maintain the consistency of our work.
But perhaps a rename would be appropriate.  \intnote{todo das ist jetzt eig so geschriebn fast schon wieder implementation (begründung) statt result...} \\

To increase the user experience with this feature, notifications are sent to the user if an error occurred or the requested symbol was already a declaration.r
\begin{figure}[H]
    \centering
    \includegraphics{results/goto.png}
    \caption{GoToDefinition Error Reporting}
    \label{fig:goto}
\end{figure}

\intnote{die msg tut iwie nich xD is aber my bad hab da noch was geändert kürzlich. punkt 2: vscode reported das grad selber bei return null, damüssen wir unsere eigene notification eig net bringen. todo}

Jumps can also be done across different files.
If the proper file is not opened, VS Code will just open it inside the workspace.
It is also possible to go to the definition of \code{this}-Expressions, which will just jump to the class definition.
The feature works also across code that is not within a block statement, for example for expressions occurring inside an \code{ensures}-clause.

\subsubsection{Rename}
Rename is a feature that could only be added, since the symbol table provides all necessary information.
If the user wants to execute a rename, all dependent symbols are automatically marked correctly as you see in figure \ref{fig:rename}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{results/rename}
    \caption{Rename of a Symbol}
    \label{fig:rename}
\end{figure}

It was embraced to provide as much user experience as possible for this feature, even if it is relatively simple.
In particular, this means if there is no renamable symbol at the cursor, the user is informed by a notification.
The algorithm will also check, if the new symbol name is valid.
This means, it must not start with an underscore or it must not be any reserved Dafny word.
Also, we limited the allowed new name to alphanumerical characters, although wild unicode names would be allowed by Dafny.\\

This could even be driven further.
For example, it could be checked, whether a symbol with the same new name already exists.
Functionality for this is already available by the symbol table, since something similar is needed by autocompletion.
Furthermore, it is currently not checked, if the new symbol name starts with a number, which is prohibited.
That is also something that could easily be added. \intnote{das sind so one-liner im code... könnten wir echt nochs chnell umsetzen}\\

Since Dafny reserved words may change in the future, the wordlist is configurable for the end-user by adjusting a config file.
The process targets more advanced users and is described in the readme file.\\

Because the symbol table reports occurrences across imported files as well, the rename feature works fine across the complete workspace.

\intnote{abschnitt gefällt mir mnicht, evtl neu schreiben. ist einfach blabla mit 0 inhalt. - find ich eig ned. }

\subsubsection{CodeLens}
CodeLens is an excellent way for the developer to see which classes and methods were used how often - and where.
In order to be able to assign the references reliably and
also to consider the references across included files, the symbol table was necessary. \\

As shown in figure \ref{fig:result_codelens_references},
not only the references to the symbols are counted,
but also dead code is lifted by a special text.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{tmpPlaceHolderTodo}
    \caption{Codelens Shows the Number of Uses}
    \label{fig:result_codelens_references}
\end{figure}

If the user clicks on one of the reference texts, a popup window opens,
as figure \ref{fig:result_codelens_references_popup} shows.
On the right hand side of the popup window all references found are listed.
If the user clicks on the corresponding references, the corresponding code
location in the right file opens on the left side - at the location within the popup.
This is very convenient for developers,
because they no longer have to jump back and forth between files and you do not have to scroll unnecessarily
through the code.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{tmpPlaceHolderTodo}
    \caption{Codelens Shows References in Pop-up}
    \label{fig:result_codelens_references_popup}
\end{figure}

Since no global symbol table is currently used for the entire workspace in the language server,
references in included files are not displayed.
This concerns all Dafny files that do not have their own main function and were included by other files. \\

There are basically two ways to improve this: \\

\textbf{Global Symbol Table}\\
We recommend this first variant.
Implement the global symbol table for the entire workspace.
This not only improves runtime by giving the updatability of individual symbols,
as described in section XXX, but automatically solves the problem.
With a symbol table for the whole workspace and no longer per file,
files automatically know if they are included by other files. \\

\textbf{Buffer "included by" Information}\\
The second variant is possible without the global symbol table, but involves some tinkering.
If a file A is included in file B, an additional buffer within file A indicates that it was included by file B.
Keeping all these references up to date is also connected with logical effort.
Therefore, it is not advisable to implement the global and updateable symbol table.

 \intnote{todo XXX mit Kapitelreferenz auf updatebare globale symbol tabelle manager dingens tun.
seh grad ned welche skapitel es ist. haben wir das schon geschrieben? todo}

\subsubsection{Automatic Code Completion}
The code suggestions for automatic completion is a very useful feature for Dafny developers.
It lists the available symbols in the current context on request.

Compared to our previous thesis, we could significantly improve the function.
Instead of displaying all found symbols in the opened file as before,
we can now use the new symbol table to consider the current scope for suggestions. \\

Our aut ocompletion support three basic types of proposals which are shown below.\\

\textbf{Proposals for the Object Instance}\\
If the user writes a dot after a symbol,
AutoCompletion looks for the symbol before the dot in the symbol table.
The available functions and variables are then proposed for the symbol found.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{tmpPlaceHolderTodo}
    \caption{AutoCompletion After Dot}
    \label{fig:result_completion_dot}
\end{figure}

For example, if an instance of class A has been created,
and then you want to access available contents of class A via the point operator
(for example \code{myInstanceOfClassA.}),
methods and variables of class A are proposed as shown in figure \ref{fig:result_completion_dot}. \\

\textbf{Class Suggestions}\\
If the keyword \code{new} is placed in front of the cursor position, followed by a space, when executing an AutoCompletion,
the proposals are limited to available classes in the current scope as shown in figure \ref{fig:result_completion_new}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{tmpPlaceHolderTodo}
    \caption{AutoCompletion After Keyword "new"}
    \label{fig:result_completion_new}
\end{figure}

\textbf{All Available Symbols as Default}\\
If none of the above cases apply to the current context,
all available symbols in the current scope are listed as default when calling AutoCompletion
as shown in figure \ref{fig:result_completion_all}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{tmpPlaceHolderTodo}
    \caption{AutoCompletion for all Symbols in Scope}
    \label{fig:result_completion_all}
\end{figure}

\textbf{Additional Usabillity Suggar}\\
As a little extra to increase the usability, when inserting a suggested function or method,
automatically opening and closing brackets are added to the Dafny source code.
 \intnote{todo immer oder nur nach einem punkt?} \\

However, when inserting methods and classes no parameter placeholders are inserted in the current state,
as you know it from other IDE's like XCode.
Technically it would be possible, as described in chapter
\ref{section:implementation:core:completion} \nameref{section:implementation:core:completion}.
This would further enhance the user-friendliness as proved in the usability test.

\subsection{Simplicity of Further Development}
Aside the features, also architectural improvements are discussed,
which increase maintainability and facilitate future extensions of the project.

\subsubsection{Symbol Table}
The symbol table was newly implemented during this project.
However, the prototype contained some symbol information that was already existing inside the pre-existing project.
That symbol table was only containing a list of strings though.
It was a very primitive approach of a symbol table.\\

The new symbol table contains proper objects.
Related information, such as the parent symbol, is now directly accessible.
Any string parsing could be completely omitted compared to the prototype.
This leads to better performance and above all to reliable symbol references.\\

All of the previous features, with the exception of AutoCompletion, do not contain much logic themselves.
They just request information from the symbol table and report it back to the client.
While the features are implemented quite robust, they only work as long as the symbol table provides proper information.\\

Whenever the symbol table fails, the underlying features will also produce nonsense.
Thus, a correct symbol table is crucial for correct functionality.\\

Dafny is a programming language offering a lot of features.
Aside common object oriented features, also functional programmatic features are present.
Figure \ref{fig:DafnyAST} shows all classes occurring inside the Dafny AST.
The writers are well aware, that the text in this figure is too small to be read.
The figure should indicate the humungous amount of AST-elements present in Dafny.
Many of them are not just inheriting from \code{Expression} or \code{Statement}, but from individual base classes.
Thus, implementing the visitor for all of them turned out to be massively time consuming.
Since the bachelor thesis is bounded by a limited time frame, it was necessary to limit the amount of Dafny language features we support.
We decided to lay our focus on the Dafny tutorial, which is done within the software engineering at HSR.
This way, the basic concepts of Dafny are supported.
However, as soon as the user starts to use more advanced language features, a symbol may be introduced within a scope that is not visited by the visitor.
If the user is using that symbol later on inside a common method body, the symbol table generator will be unable to locate the symbol's declaration and thus fail.
An overview of the supported expressions and statements was given in section \ref{section:analysis_dafnyASTStuff}.\\

\intnote{würd hjier nciht schreiben, was genau failed, oder? weil das fägnt schon bei arrays oder listen an. iwo bei implemetnation ahben wir ja geschrieben, was wir analyisert ahebn. was meinst du marcel? hmm vor und nachteile xD kurz erwähnen
"weil visitor nicht komplett implementiert, gehen einzelne Sprachfeatures wie beispielsweise Arrays oder Listen nicht korrekt"?}

It is subject of further development to complete the symbol table.
It is the first priority in further development of the language server.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{results/symboltable_dafnyast.png}
    \caption{All Dafny AST Classes}
    \label{fig:dafnyASTOverview}
\end{figure}

\subsubsection{Server Architectural Improvements}
At the beginning of the thesis, the server's dependency graph was quite a mess.
During development, the code was constantly cleaned up and dependencies were resolved.

While the project is quite large and has a lot of dependencies, they could be well organized.
As seen in figure \ref{fig:dependency_graph}, all dependency are now pointing downwards, just as it should be.
Within the picture, dependencies to the \code{Resources} package are excluded for more overview.
The core layer of the project, containing \code{SymbolTable}, \code{Handler} and \code{Core}, have some sideward dependencies, which could not be avoided completely, since these packages are strongly coupled.

Aside the broad architectural layout, many small refactorings were made to keep the code clean.
This includes the creation of smaller classes and smaller methods with single responsibilities.
A good example for this is the config initialization, which was one single large class at first.
After refactoring, it was split into small, well organized sub-classes.

Any important classes, such as handlers, providers or classes related to the symbol table are programmed against interfaces.
This allows for optimal testing, for example by implementing the same interface with a fake instance.

\subsubsection{Client Architectural Improvements}
The client was completely restructured.
Isolated, small, preferably encapsulated components were programmed.
Components are now no longer directly dependent on each other but program against interfaces.
Modules were created and these export only the most necessary interfaces and components to the outside.
If complex logic would have to be implemented for the client at a later date due to new features,
this encapsulation by interfaces is ideal for writing tests. \\

This resulted in less encapsulation and higher coherence.
These two motivations also encouraged the complete isolation of VS Code modules.
We isolated the VS code components in a separate module if possible.
This minimizes the effort to migrate the plugin to another IDE.

\subsection{Publication of the Plugin}
To make our new Dafny plugin easy for Dafny developers to install and use,
it has been published in the Visual Studio Marketplace as a preview version \cite{our-dafny-plugin}.
Any Windows user can install it, try it out and leave feedback.

This chapter describes the release of the plugin and the associated possibilities.

\subsubsection{Rebase of the Dafny Language Server to the Dafny Project}
Our Dafny language server has reached a point where it can be merged back into the original Dafny project \cite{dafny_lang_github}.
However, since there is still a problem with platform independence, no rebase was carried out with regard to the server in part.
As soon as the Language server can be successfully started with mono, nothing stands in the way of a rebase.

\subsubsection{Publishing of the Client Plugin}
Our plugin does not replace the old plugin, but supplements the plugin store as its own new preview plugin \cite{our-dafny-plugin}.
The publication in the plugin store happens automatically. \\

We rebased our GitLab repository to a GitHub repository.
In the original GitHub CI process, the pipeline \code{release-marketplace}
was adapted for the plugin store release by Fabian Hauser \cite{our-dafny-plugin-github-publish}.
Once the rebase from Dafny language server to the Dafny project is done,
the preview plugin can replace the original plugin.
Since the repository already exists in GitHub, the effort is minimal.

\subsubsection{Download of the Dafny Language Server}
In the original plugin, the Dafny project was downloaded via the release builds of GitHub \cite{dafny_lang_builds}.

As discussed in section \ref{section:implementation:client:download} \nameref{section:implementation:client:download},
we have written an interface for this original process.

Once the rebase from Dafny language server to the Dafny project is done,
the client can download the download the Dafny language server
(which will be included in the Dafny project) as it was inizially done.
Due to the written interface the component can be exchanged with minimal effort. \\

The current download component downloads the Dafny language server from a private server \cite{client-serverStringResources}.

We decided on this simple variant in order to keep the effort for this temporary solution as low as possible.
Alternatively, this process could have been automated with the GitLab CI using the GitLab API \cite{gitlab-api} to download the CI artifacts
or the artifacts could also be made available through the CI process as a static website with GitLab Pages \cite{gitlab-pages}.

\subsubsection{Platform Independence}
In order to reach the widest possible audience with our plugin,
cross platform support was very important to us right from the start.
As described in chapter \ref{section:implementation:mono} \nameref{section:implementation:mono},
we unfortunately had to switch from .NET Core to .Net Framework
about Dafny. Our language server had difficulties with mono to be executed correctly. \\

Unfortunately, the problem could not be solved within a reasonable amount of time,
and was unfortunately not completed by the end.
Therefore our language server - and therefore also the plugin - is
unfortunately not executable correctly on macOS or Linux. \\

Platform independence was an essential goal and is unfortunately pending in consultation with our supervisor.
As a consequence, our plugin cannot replace the existing plugin,
but was released as a separate plugin installation marked as preview version \cite{our-dafny-plugin}.
